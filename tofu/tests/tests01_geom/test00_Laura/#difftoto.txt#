diff --git a/tofu/geom/_GG02_LM.pyx b/tofu/geom/_GG02_LM.pyx
index 87125d0..b13e409 100644
--- a/tofu/geom/_GG02_LM.pyx
+++ b/tofu/geom/_GG02_LM.pyx
@@ -22,6 +22,13 @@ __all__ = ['LOS_Calc_PInOut_VesStruct']
 
 
 
+# copy declarations from libcpp.vector to allow nogil
+# cdef extern from "<vector>" namespace "std":
+#     cdef cppclass vector[T]:
+#         void push_back(T&) nogil
+#         size_t size()
+#         T& operator[](size_t)
+
 ########################################################
 ########################################################
 #       PIn POut
@@ -34,7 +41,7 @@ __all__ = ['LOS_Calc_PInOut_VesStruct']
 def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double, ndim=2] dus,
                               cnp.ndarray[double, ndim=2,mode='c'] VPoly,
                               cnp.ndarray[double, ndim=2,mode='c'] VIn,
-                              Lim=None, int nLim=-1,
+                              Lim=None, int nLim=-1, int ntotStrtuct=0,
                               LSPoly=None, LSLim=None, lSnLim=None, LSVIn=None,
                               RMin=None, Forbid=True,
                               double EpsUz=1.e-6, double EpsVz=1.e-9, double EpsA=1.e-9,
@@ -90,11 +97,12 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
             "Arg VType must be a str in ['Tor','Lin']!")
 
     cdef int ii, jj, iloc
+    cdef int ind_lim_data = 0
     cdef bool v
     cdef bool found_new_kout
     cdef double kpin_jj
     cdef double kpout_jj
-    cdef double L0, L1
+    cdef double L0=0., L1=0.
     cdef int ind_tmp
     cdef int len_lim
     cdef int num_los = Ds.shape[1]
@@ -118,6 +126,12 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
     cdef cnp.ndarray[double,ndim=2] VPerpOut
     
 
+    # cdef vector[double] llim_ves_view
+    # cdef vector[double] lbounds
+    # cdef vector[double] langles
+    llim_ves_view =[]
+    lbounds = []
+    langles = []
     if nLim==0:
         lim_ves_view = None
     elif nLim==1:
@@ -129,7 +143,25 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
             if lSnLim[ii]==0:
                 LSLim[ii] = None
             elif lSnLim[ii]==1:
-                LSLim[ii] = [LSLim[ii][0,0],LSLim[ii][0,1]]
+                lim_ves[0] = LSLim[ii][0,0]
+                lim_ves[1] = LSLim[ii][0,1]
+                lim_ves_view = lim_ves
+
+
+                lim_ves_view=None
+                bounds = get_bbox_poly_extruded(np.asarray(LSPoly[ii]))
+                langles.push_back([0.,0.])
+                llim_ves_view.append(lim_ves_view)
+                lbounds.append(bounds)
+                langles.append([0.,0.])
+
+                L0 = Catan2(Csin(lim_ves_view[0]),Ccos(lim_ves_view[0]))
+                L1 = Catan2(Csin(lim_ves_view[1]),Ccos(lim_ves_view[1]))
+                bounds = get_bbox_poly_limited(np.asarray(LSPoly[ii]), [L0, L1])
+                llim_ves_view.append(lim_ves_view)
+                lbounds.append(bounds)
+                langles.append([L0, L1])
+
 
     if VType.lower()=='tor':
         # RMin is necessary to avoid looking on the other side of the tokamak
@@ -147,52 +179,65 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
                                                EpsPlane=EpsPlane)
 
         # kpout_view = kPOut
-
         # If there are Struct, call the same function
         # Structural optimzation : do everything in one big for loop and only
         # keep the relevant points (to save memory)
         if LSPoly is not None:
 
-            for ii in range(0,len(LSPoly)):
-
-                if LSLim[ii] is None or not all([hasattr(ll,'__iter__') for ll in LSLim[ii]]):
-                    lslim = [LSLim[ii]]
-                else:
-                    lslim = LSLim[ii]
-                len_lim = len(lslim)
-
-                for jj in range(len_lim):
-
-                    # We compute the structure's bounding box:
-                    if lslim[jj] is not None:
-                        lim_ves[0] = lslim[jj][0]
-                        lim_ves[1] = lslim[jj][1]
-                        lim_ves_view = lim_ves
-                        L0 = Catan2(Csin(lim_ves_view[0]),Ccos(lim_ves_view[0]))
-                        L1 = Catan2(Csin(lim_ves_view[1]),Ccos(lim_ves_view[1]))
-                        bounds = get_bbox_poly_limited(np.asarray(LSPoly[ii]), [L0, L1])
+            print(lbounds)
+            for ind_tmp in range(0, num_los):
+                # print("For los = ", ind_tmp)
+                # We get the last kpout:
+                kpout_jj = kPOut[ind_tmp]
+                kpin_loc[0] = kpout_jj
+                indin_loc[0] = IOut[2,ind_tmp]
+                # for iloc in range(3):
+                #     los_orig_loc[iloc] = Ds[iloc, ind_tmp]
+                #     los_dirv_loc[iloc] = dus[iloc, ind_tmp]
+                #     last_pout[iloc] = kpout_jj * los_dirv_loc[iloc] + los_orig_loc[iloc]
+                los_orig_loc[0] = Ds[0, ind_tmp]
+                los_orig_loc[1] = Ds[1, ind_tmp]
+                los_orig_loc[2] = Ds[2, ind_tmp]
+                los_dirv_loc[0] = dus[0, ind_tmp]
+                los_dirv_loc[1] = dus[1, ind_tmp]
+                los_dirv_loc[2] = dus[2, ind_tmp] 
+                last_pout[0] = kpout_jj * los_dirv_loc[0] + los_orig_loc[0]
+                last_pout[1] = kpout_jj * los_dirv_loc[1] + los_orig_loc[1]
+                last_pout[2] = kpout_jj * los_dirv_loc[2] + los_orig_loc[2]
+
+                for ii in range(0,len(LSPoly)):
+                    #print()
+                    #print("For structure = ", ii)
+                
+                    if LSLim[ii] is None or not all([hasattr(ll,'__iter__') for ll in LSLim[ii]]):
+                        lslim = [LSLim[ii]]
                     else:
-                        lim_ves_view=None
-                        bounds = get_bbox_poly_extruded(np.asarray(LSPoly[ii]))
-
-                    for ind_tmp in range(num_los):
-                        # We get the last kpout:
-                        kpout_jj = kPOut[ind_tmp]
-                        kpin_loc[0] = kpout_jj
-                        indin_loc[0] = IOut[2,ind_tmp]
-                        # for iloc in range(3):
-                        #     los_orig_loc[iloc] = Ds[iloc, ind_tmp]
-                        #     los_dirv_loc[iloc] = dus[iloc, ind_tmp]
-                        #     last_pout[iloc] = kpout_jj * los_dirv_loc[iloc] + los_orig_loc[iloc]
-                        los_orig_loc[0] = Ds[0, ind_tmp]
-                        los_orig_loc[1] = Ds[1, ind_tmp]
-                        los_orig_loc[2] = Ds[2, ind_tmp]
-                        los_dirv_loc[0] = dus[0, ind_tmp]
-                        los_dirv_loc[1] = dus[1, ind_tmp]
-                        los_dirv_loc[2] = dus[2, ind_tmp] 
-                        last_pout[0] = kpout_jj * los_dirv_loc[0] + los_orig_loc[0]
-                        last_pout[1] = kpout_jj * los_dirv_loc[1] + los_orig_loc[1]
-                        last_pout[2] = kpout_jj * los_dirv_loc[2] + los_orig_loc[2]
+                        lslim = LSLim[ii]
+                    len_lim = len(lslim)
+                
+                    for jj in range(0, len_lim):
+                        #print("For limited strucutre = ", jj)
+                
+                        # We compute the structure's bounding box:
+                        # if lslim[jj] is not None:
+                        #     lim_ves[0] = lslim[jj][0]
+                        #     lim_ves[1] = lslim[jj][1]
+                        #     lim_ves_view = lim_ves
+                        #     L0 = Catan2(Csin(lim_ves_view[0]),Ccos(lim_ves_view[0]))
+                        #     L1 = Catan2(Csin(lim_ves_view[1]),Ccos(lim_ves_view[1]))
+                        #     bounds = get_bbox_poly_limited(np.asarray(LSPoly[ii]), [L0, L1])
+                        # else:
+                        #     lim_ves_view=None
+                        #     bounds = get_bbox_poly_extruded(np.asarray(LSPoly[ii]))
+
+                        print(ind_lim_data)
+                        bounds = lbounds[ind_lim_data]
+                        [L0, L1] = langles[ind_lim_data]
+                        lim_ves_view = llim_ves_view[ind_lim_data]
+                        ind_lim_data += 1
+                        # if ind_tmp == 706:
+                        #     print("origin los = ", los_orig_loc[0], los_orig_loc[1], los_orig_loc[2],
+                        #         "new pout = ", last_pout[0], last_pout[1], last_pout[2])
                         # We compute new values
                         # print("struct =", ii, "sub struc =", jj,"for los =", ind_tmp)
                         found_new_kout = compute_kout_los_on_filled(los_orig_loc, los_dirv_loc,
@@ -206,7 +251,7 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
                                                               Forbid=Forbid,
                                                               EpsUz=EpsUz, EpsVz=EpsVz,
                                                               EpsA=EpsA, EpsB=EpsB,
-                                                              EpsPlane=EpsPlane)
+                                                              EpsPlane=EpsPlane)                        
                         if found_new_kout :
                             kPOut[ind_tmp] = kpin_loc[0]
                             VperpOut[0,ind_tmp] = struct_vperpin_view[0]
@@ -215,6 +260,13 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
                             IOut[2,ind_tmp] = indin_loc[0]
                             IOut[0,ind_tmp] = 1+ii
                             IOut[1,ind_tmp] = jj
+                            last_pout[0] = kPOut[ind_tmp] * los_dirv_loc[0] + los_orig_loc[0]
+                            last_pout[1] = kPOut[ind_tmp] * los_dirv_loc[1] + los_orig_loc[1]
+                            last_pout[2] = kPOut[ind_tmp] * los_dirv_loc[2] + los_orig_loc[2]
+
+                            #print("yup")
+                            # if ind_tmp==706:
+                            #     print("kout = ", kPOut[ind_tmp], "kpin = ", kpout_jj, kpin_loc[0])
 
     return kPIn, kPOut, VperpOut, IOut
 
@@ -234,18 +286,18 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
                                 bint Forbid, double EpsUz,
                                 double EpsVz, double EpsA,
                                 double EpsB, double EpsPlane) :
-    cdef int jj#, Ns=vIn.shape[1]
-    cdef double upscaDp, upar2, Dpar2, Crit2, kout, kin
+    cdef int jj
     cdef int indin=0, Done=0
+    cdef int Forbidbis, Forbid0
+    cdef bint inter_bbox
+    cdef double upscaDp, upar2, Dpar2, Crit2, kout, kin
     cdef double L, S1X=0., S1Y=0., S2X=0., S2Y=0., sca=0., sca0=0., sca1=0., sca2=0.
     cdef double q, C, delta, sqd, k, sol0, sol1, phi=0.
     cdef double v0, v1, A, B, ephiIn0, ephiIn1
     cdef double SOut1, SOut0
     cdef double SIn1, SIn0
-    cdef int Forbidbis, Forbid0
     cdef double res_kin = kpin_loc[0]
-    cdef bint inter_bbox
-
+    cdef double[3] opp_dir
 
     # We check if the ray intersects it 
     inter_bbox = ray_intersects_abba_bbox(bounds, Ds, us)
@@ -254,8 +306,14 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
 
     # We check if the bounding box is not actually "behind"
     # the last object intersected
-    print(last_pout_coords[0],last_pout_coords[1],last_pout_coords[2])
+    # opp_dir[0] = -us[0]
+    # opp_dir[1] = -us[1]
+    # opp_dir[2] = -us[2]
     inter_bbox = ray_intersects_abba_bbox(bounds, last_pout_coords, us)
+
+    # print("last pout = ", last_pout_coords[0], last_pout_coords[1], last_pout_coords[2],
+    #       "Ds =", Ds[0], Ds[1], Ds[2],
+    #       "vect dire = ", us[0], us[1], us[2])
     # in this case we dont want the ray to intersect the bbox, else the
     # last k found is in front of the box.
     if inter_bbox:
@@ -284,7 +342,7 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
     S2X = (Rmin**2*Ds[0]-Rmin*Ds[1]*L)/Dpar2
     S2Y = (Rmin**2*Ds[1]+Rmin*Ds[0]*L)/Dpar2
 
-    print("s1, s2, L, rmin = ", S1X, S1Y, S2X, S2Y, L, Rmin)
+    # print("s1, s2, L, rmin = ", S1X, S1Y, S2X, S2Y, L, Rmin)
     L=0.
     S1X = 0.
     S1Y = 0.
@@ -520,7 +578,7 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
 
     # print("  For Line ", ii, "  test = ", inter_bbox, " and kout = ", Done, kin, kout)
     if Done==1:
-        if kin<kout:
+        if kin<kout and kin < res_kin:
             kpin_loc[0] = kin
             if indin==-1:
                 vperpin[0] = Csin(L0)
@@ -534,13 +592,13 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
                 SIn0 = Ds[0] + kin*us[0]
                 SIn1 = Ds[1] + kin*us[1]
                 phi = Catan2(SIn1,SIn0)
-                vperpin[0] = -Ccos(phi)*vIn[0,indin]
-                vperpin[1] = -Csin(phi)*vIn[0,indin]
-                vperpin[2] = -vIn[1,indin]
+                vperpin[0] = Ccos(phi)*vIn[0,indin]
+                vperpin[1] = Csin(phi)*vIn[0,indin]
+                vperpin[2] = vIn[1,indin]
             indin_loc[0] = indin
 
                 
-    return res_kin == kpin_loc[0]
+    return res_kin != kpin_loc[0]
 
 # et creer vecteurs
 #    return np.asarray(kIn), np.asarray(kOut), np.asarray(vPerpOut), np.asarray(indOut)
@@ -548,7 +606,9 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
 @cython.cdivision(True)
 @cython.wraparound(False)
 @cython.boundscheck(False)
-cdef inline bint ray_intersects_abba_bbox(double[6] bounds, double [3] ds, double [3] us) nogil:
+cdef inline bint ray_intersects_abba_bbox(const double[6] bounds,
+                                          const double[3] ds,
+                                          const double[3] us) :
     """
     bounds = [3d coords of lowerleftback point of bounding box,
               3d coords of upperrightfront point of bounding box]
@@ -563,6 +623,7 @@ cdef inline bint ray_intersects_abba_bbox(double[6] bounds, double [3] ds, doubl
     cdef int t0 = 1000000
     cdef bint res
     cdef int ii
+
     # computing sing and direction
     for  ii in range(3):
         if us[ii]*us[ii] < 1.e-9:
@@ -579,6 +640,7 @@ cdef inline bint ray_intersects_abba_bbox(double[6] bounds, double [3] ds, doubl
     tymin = (bounds[(sign[1])*3 + 1] - ds[1]) * inv_direction[1];
     tymax = (bounds[(1-sign[1])*3+1] - ds[1]) * inv_direction[1];
     if ( (tmin > tymax) or (tymin > tmax) ):
+        # print("case 1: ")
         return False
     if (tymin > tmin):
         tmin = tymin
@@ -587,12 +649,18 @@ cdef inline bint ray_intersects_abba_bbox(double[6] bounds, double [3] ds, doubl
     tzmin = (bounds[(sign[2])*3+2] - ds[2]) * inv_direction[2]
     tzmax = (bounds[(1-sign[2])*3+2] - ds[2]) * inv_direction[2]
     if ( (tmin > tzmax) or (tzmin > tmax) ):
+        # print("case 2")
         return False
     if (tzmin > tmin):
         tmin = tzmin
     if (tzmax < tmax):
         tmax = tzmax
+
     res = (tmin < t0) and (tmax > -t0)
+    if (tmin < 0):
+        return False
+    # if not res:
+    #     print("case 3")
     return  res
 
 
diff --git a/tofu/geom/_GG03_LM.pyx b/tofu/geom/_GG03_LM.pyx
index 87125d0..6b31491 100644
--- a/tofu/geom/_GG03_LM.pyx
+++ b/tofu/geom/_GG03_LM.pyx
@@ -22,6 +22,13 @@ __all__ = ['LOS_Calc_PInOut_VesStruct']
 
 
 
+# copy declarations from libcpp.vector to allow nogil
+# cdef extern from "<vector>" namespace "std":
+#     cdef cppclass vector[T]:
+#         void push_back(T&) nogil
+#         size_t size()
+#         T& operator[](size_t)
+
 ########################################################
 ########################################################
 #       PIn POut
@@ -90,11 +97,12 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
             "Arg VType must be a str in ['Tor','Lin']!")
 
     cdef int ii, jj, iloc
+    cdef int ind_lim_data = 0
     cdef bool v
     cdef bool found_new_kout
     cdef double kpin_jj
     cdef double kpout_jj
-    cdef double L0, L1
+    cdef double L0=0., L1=0.
     cdef int ind_tmp
     cdef int len_lim
     cdef int num_los = Ds.shape[1]
@@ -118,6 +126,12 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
     cdef cnp.ndarray[double,ndim=2] VPerpOut
     
 
+    # cdef vector[double] llim_ves_view
+    # cdef vector[double] lbounds
+    # cdef vector[double] langles
+    llim_ves_view =[]
+    lbounds = []
+    langles = []
     if nLim==0:
         lim_ves_view = None
     elif nLim==1:
@@ -127,9 +141,29 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
     if lSnLim is not None:
         for ii in range(0,len(lSnLim)):
             if lSnLim[ii]==0:
+                print("im here ............................... ")
                 LSLim[ii] = None
+                lim_ves_view=None
+                bounds = get_bbox_poly_extruded(np.asarray(LSPoly[ii]))
+                # llim_ves_view.push_back(0.)
+                # llim_ves_view.push_back(0.)
+                # lbounds.push_back(bounds[0],bounds[1],bounds[2],bounds[3],bounds[4],bounds[5])
+                # langles.push_back([0.,0.])
+                llim_ves_view.append(lim_ves_view)
+                lbounds.append(bounds)
+                langles.append([0.,0.])
             elif lSnLim[ii]==1:
-                LSLim[ii] = [LSLim[ii][0,0],LSLim[ii][0,1]]
+                lim_ves[0] = LSLim[ii][0,0]
+                lim_ves[1] = LSLim[ii][0,1]
+                lim_ves_view = lim_ves
+                L0 = Catan2(Csin(lim_ves_view[0]),Ccos(lim_ves_view[0]))
+                L1 = Catan2(Csin(lim_ves_view[1]),Ccos(lim_ves_view[1]))
+                bounds = get_bbox_poly_limited(np.asarray(LSPoly[ii]), [L0, L1])
+                llim_ves_view.append(lim_ves_view)
+                lbounds.append(bounds)
+                langles.append([L0, L1])
+            print("for ii = ", ii, " bounds ", bounds)
+                
 
     if VType.lower()=='tor':
         # RMin is necessary to avoid looking on the other side of the tokamak
@@ -147,52 +181,65 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
                                                EpsPlane=EpsPlane)
 
         # kpout_view = kPOut
-
         # If there are Struct, call the same function
         # Structural optimzation : do everything in one big for loop and only
         # keep the relevant points (to save memory)
         if LSPoly is not None:
 
-            for ii in range(0,len(LSPoly)):
-
-                if LSLim[ii] is None or not all([hasattr(ll,'__iter__') for ll in LSLim[ii]]):
-                    lslim = [LSLim[ii]]
-                else:
-                    lslim = LSLim[ii]
-                len_lim = len(lslim)
-
-                for jj in range(len_lim):
-
-                    # We compute the structure's bounding box:
-                    if lslim[jj] is not None:
-                        lim_ves[0] = lslim[jj][0]
-                        lim_ves[1] = lslim[jj][1]
-                        lim_ves_view = lim_ves
-                        L0 = Catan2(Csin(lim_ves_view[0]),Ccos(lim_ves_view[0]))
-                        L1 = Catan2(Csin(lim_ves_view[1]),Ccos(lim_ves_view[1]))
-                        bounds = get_bbox_poly_limited(np.asarray(LSPoly[ii]), [L0, L1])
+            print(lbounds)
+            for ind_tmp in range(0, num_los):
+                # print("For los = ", ind_tmp)
+                # We get the last kpout:
+                kpout_jj = kPOut[ind_tmp]
+                kpin_loc[0] = kpout_jj
+                indin_loc[0] = IOut[2,ind_tmp]
+                # for iloc in range(3):
+                #     los_orig_loc[iloc] = Ds[iloc, ind_tmp]
+                #     los_dirv_loc[iloc] = dus[iloc, ind_tmp]
+                #     last_pout[iloc] = kpout_jj * los_dirv_loc[iloc] + los_orig_loc[iloc]
+                los_orig_loc[0] = Ds[0, ind_tmp]
+                los_orig_loc[1] = Ds[1, ind_tmp]
+                los_orig_loc[2] = Ds[2, ind_tmp]
+                los_dirv_loc[0] = dus[0, ind_tmp]
+                los_dirv_loc[1] = dus[1, ind_tmp]
+                los_dirv_loc[2] = dus[2, ind_tmp] 
+                last_pout[0] = kpout_jj * los_dirv_loc[0] + los_orig_loc[0]
+                last_pout[1] = kpout_jj * los_dirv_loc[1] + los_orig_loc[1]
+                last_pout[2] = kpout_jj * los_dirv_loc[2] + los_orig_loc[2]
+
+                for ii in range(0,len(LSPoly)):
+                    #print()
+                    #print("For structure = ", ii)
+                
+                    if LSLim[ii] is None or not all([hasattr(ll,'__iter__') for ll in LSLim[ii]]):
+                        lslim = [LSLim[ii]]
                     else:
-                        lim_ves_view=None
-                        bounds = get_bbox_poly_extruded(np.asarray(LSPoly[ii]))
-
-                    for ind_tmp in range(num_los):
-                        # We get the last kpout:
-                        kpout_jj = kPOut[ind_tmp]
-                        kpin_loc[0] = kpout_jj
-                        indin_loc[0] = IOut[2,ind_tmp]
-                        # for iloc in range(3):
-                        #     los_orig_loc[iloc] = Ds[iloc, ind_tmp]
-                        #     los_dirv_loc[iloc] = dus[iloc, ind_tmp]
-                        #     last_pout[iloc] = kpout_jj * los_dirv_loc[iloc] + los_orig_loc[iloc]
-                        los_orig_loc[0] = Ds[0, ind_tmp]
-                        los_orig_loc[1] = Ds[1, ind_tmp]
-                        los_orig_loc[2] = Ds[2, ind_tmp]
-                        los_dirv_loc[0] = dus[0, ind_tmp]
-                        los_dirv_loc[1] = dus[1, ind_tmp]
-                        los_dirv_loc[2] = dus[2, ind_tmp] 
-                        last_pout[0] = kpout_jj * los_dirv_loc[0] + los_orig_loc[0]
-                        last_pout[1] = kpout_jj * los_dirv_loc[1] + los_orig_loc[1]
-                        last_pout[2] = kpout_jj * los_dirv_loc[2] + los_orig_loc[2]
+                        lslim = LSLim[ii]
+                    len_lim = len(lslim)
+                
+                    for jj in range(0, len_lim):
+                        #print("For limited strucutre = ", jj)
+                
+                        # We compute the structure's bounding box:
+                        # if lslim[jj] is not None:
+                        #     lim_ves[0] = lslim[jj][0]
+                        #     lim_ves[1] = lslim[jj][1]
+                        #     lim_ves_view = lim_ves
+                        #     L0 = Catan2(Csin(lim_ves_view[0]),Ccos(lim_ves_view[0]))
+                        #     L1 = Catan2(Csin(lim_ves_view[1]),Ccos(lim_ves_view[1]))
+                        #     bounds = get_bbox_poly_limited(np.asarray(LSPoly[ii]), [L0, L1])
+                        # else:
+                        #     lim_ves_view=None
+                        #     bounds = get_bbox_poly_extruded(np.asarray(LSPoly[ii]))
+
+                        print(ind_lim_data)
+                        bounds = lbounds[ind_lim_data]
+                        [L0, L1] = langles[ind_lim_data]
+                        lim_ves_view = llim_ves_view[ind_lim_data]
+                        ind_lim_data += 1
+                        # if ind_tmp == 706:
+                        #     print("origin los = ", los_orig_loc[0], los_orig_loc[1], los_orig_loc[2],
+                        #         "new pout = ", last_pout[0], last_pout[1], last_pout[2])
                         # We compute new values
                         # print("struct =", ii, "sub struc =", jj,"for los =", ind_tmp)
                         found_new_kout = compute_kout_los_on_filled(los_orig_loc, los_dirv_loc,
@@ -206,7 +253,7 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
                                                               Forbid=Forbid,
                                                               EpsUz=EpsUz, EpsVz=EpsVz,
                                                               EpsA=EpsA, EpsB=EpsB,
-                                                              EpsPlane=EpsPlane)
+                                                              EpsPlane=EpsPlane)                        
                         if found_new_kout :
                             kPOut[ind_tmp] = kpin_loc[0]
                             VperpOut[0,ind_tmp] = struct_vperpin_view[0]
@@ -215,6 +262,13 @@ def LOS_Calc_PInOut_VesStruct(cnp.ndarray[double, ndim=2] Ds, cnp.ndarray[double
                             IOut[2,ind_tmp] = indin_loc[0]
                             IOut[0,ind_tmp] = 1+ii
                             IOut[1,ind_tmp] = jj
+                            last_pout[0] = kPOut[ind_tmp] * los_dirv_loc[0] + los_orig_loc[0]
+                            last_pout[1] = kPOut[ind_tmp] * los_dirv_loc[1] + los_orig_loc[1]
+                            last_pout[2] = kPOut[ind_tmp] * los_dirv_loc[2] + los_orig_loc[2]
+
+                            #print("yup")
+                            # if ind_tmp==706:
+                            #     print("kout = ", kPOut[ind_tmp], "kpin = ", kpout_jj, kpin_loc[0])
 
     return kPIn, kPOut, VperpOut, IOut
 
@@ -234,18 +288,18 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
                                 bint Forbid, double EpsUz,
                                 double EpsVz, double EpsA,
                                 double EpsB, double EpsPlane) :
-    cdef int jj#, Ns=vIn.shape[1]
-    cdef double upscaDp, upar2, Dpar2, Crit2, kout, kin
+    cdef int jj
     cdef int indin=0, Done=0
+    cdef int Forbidbis, Forbid0
+    cdef bint inter_bbox
+    cdef double upscaDp, upar2, Dpar2, Crit2, kout, kin
     cdef double L, S1X=0., S1Y=0., S2X=0., S2Y=0., sca=0., sca0=0., sca1=0., sca2=0.
     cdef double q, C, delta, sqd, k, sol0, sol1, phi=0.
     cdef double v0, v1, A, B, ephiIn0, ephiIn1
     cdef double SOut1, SOut0
     cdef double SIn1, SIn0
-    cdef int Forbidbis, Forbid0
     cdef double res_kin = kpin_loc[0]
-    cdef bint inter_bbox
-
+    cdef double[3] opp_dir
 
     # We check if the ray intersects it 
     inter_bbox = ray_intersects_abba_bbox(bounds, Ds, us)
@@ -254,8 +308,14 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
 
     # We check if the bounding box is not actually "behind"
     # the last object intersected
-    print(last_pout_coords[0],last_pout_coords[1],last_pout_coords[2])
+    # opp_dir[0] = -us[0]
+    # opp_dir[1] = -us[1]
+    # opp_dir[2] = -us[2]
     inter_bbox = ray_intersects_abba_bbox(bounds, last_pout_coords, us)
+
+    # print("last pout = ", last_pout_coords[0], last_pout_coords[1], last_pout_coords[2],
+    #       "Ds =", Ds[0], Ds[1], Ds[2],
+    #       "vect dire = ", us[0], us[1], us[2])
     # in this case we dont want the ray to intersect the bbox, else the
     # last k found is in front of the box.
     if inter_bbox:
@@ -284,7 +344,7 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
     S2X = (Rmin**2*Ds[0]-Rmin*Ds[1]*L)/Dpar2
     S2Y = (Rmin**2*Ds[1]+Rmin*Ds[0]*L)/Dpar2
 
-    print("s1, s2, L, rmin = ", S1X, S1Y, S2X, S2Y, L, Rmin)
+    # print("s1, s2, L, rmin = ", S1X, S1Y, S2X, S2Y, L, Rmin)
     L=0.
     S1X = 0.
     S1Y = 0.
@@ -520,7 +580,7 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
 
     # print("  For Line ", ii, "  test = ", inter_bbox, " and kout = ", Done, kin, kout)
     if Done==1:
-        if kin<kout:
+        if kin<kout and kin < res_kin:
             kpin_loc[0] = kin
             if indin==-1:
                 vperpin[0] = Csin(L0)
@@ -534,13 +594,13 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
                 SIn0 = Ds[0] + kin*us[0]
                 SIn1 = Ds[1] + kin*us[1]
                 phi = Catan2(SIn1,SIn0)
-                vperpin[0] = -Ccos(phi)*vIn[0,indin]
-                vperpin[1] = -Csin(phi)*vIn[0,indin]
-                vperpin[2] = -vIn[1,indin]
+                vperpin[0] = Ccos(phi)*vIn[0,indin]
+                vperpin[1] = Csin(phi)*vIn[0,indin]
+                vperpin[2] = vIn[1,indin]
             indin_loc[0] = indin
 
                 
-    return res_kin == kpin_loc[0]
+    return res_kin != kpin_loc[0]
 
 # et creer vecteurs
 #    return np.asarray(kIn), np.asarray(kOut), np.asarray(vPerpOut), np.asarray(indOut)
@@ -548,7 +608,9 @@ cdef inline bint compute_kout_los_on_filled(double [3] Ds, double [3] us,
 @cython.cdivision(True)
 @cython.wraparound(False)
 @cython.boundscheck(False)
-cdef inline bint ray_intersects_abba_bbox(double[6] bounds, double [3] ds, double [3] us) nogil:
+cdef inline bint ray_intersects_abba_bbox(const double[6] bounds,
+                                          const double[3] ds,
+                                          const double[3] us) :
     """
     bounds = [3d coords of lowerleftback point of bounding box,
               3d coords of upperrightfront point of bounding box]
@@ -563,6 +625,7 @@ cdef inline bint ray_intersects_abba_bbox(double[6] bounds, double [3] ds, doubl
     cdef int t0 = 1000000
     cdef bint res
     cdef int ii
+
     # computing sing and direction
     for  ii in range(3):
         if us[ii]*us[ii] < 1.e-9:
@@ -579,6 +642,7 @@ cdef inline bint ray_intersects_abba_bbox(double[6] bounds, double [3] ds, doubl
     tymin = (bounds[(sign[1])*3 + 1] - ds[1]) * inv_direction[1];
     tymax = (bounds[(1-sign[1])*3+1] - ds[1]) * inv_direction[1];
     if ( (tmin > tymax) or (tymin > tmax) ):
+        # print("case 1: ")
         return False
     if (tymin > tmin):
         tmin = tymin
@@ -587,12 +651,18 @@ cdef inline bint ray_intersects_abba_bbox(double[6] bounds, double [3] ds, doubl
     tzmin = (bounds[(sign[2])*3+2] - ds[2]) * inv_direction[2]
     tzmax = (bounds[(1-sign[2])*3+2] - ds[2]) * inv_direction[2]
     if ( (tmin > tzmax) or (tzmin > tmax) ):
+        # print("case 2")
         return False
     if (tzmin > tmin):
         tmin = tzmin
     if (tzmax < tmax):
         tmax = tzmax
+
     res = (tmin < t0) and (tmax > -t0)
+    if (tmin < 0):
+        return False
+    # if not res:
+    #     print("case 3")
     return  res
 
 
diff --git a/tofu/geom/_core.py b/tofu/geom/_core.py
index f861cbf..117a578 100644
--- a/tofu/geom/_core.py
+++ b/tofu/geom/_core.py
@@ -2416,14 +2416,16 @@ class Rays(utils.ToFuObject):
 
             lS = [ss for ss in lS if ss._InOut=='out']
             lSPoly, lSVIn, lSLim, lSnLim = [], [], [], []
+            lSBounds = []
+            num_tot_structs = 0
             for ss in lS:
                 lSPoly.append(ss.Poly_closed)
                 lSVIn.append(ss.dgeom['VIn'])
                 lSLim.append(ss.Lim)
                 lSnLim.append(ss.nLim)
-
+                num_tot_structs + = 1 + ss.nLim - 1
             largs = [D, u, VPoly, VVIn]
-            dkwd = dict(Lim=Lim, nLim=nLim,
+            dkwd = dict(Lim=Lim, nLim=nLim, ntotStruct=num_tot_struct,
                         LSPoly=lSPoly, LSLim=lSLim,
                         lSnLim=lSnLim, LSVIn=lSVIn, VType=VType,
                         RMin=None, Forbid=True, EpsUz=1.e-6, EpsVz=1.e-9,
diff --git a/tofu/tests/tests01_geom/test00_Laura/test_LOS_west_geom.py b/tofu/tests/tests01_geom/test00_Laura/test_LOS_west_geom.py
index f858e2b..6912adb 100644
--- a/tofu/tests/tests01_geom/test00_Laura/test_LOS_west_geom.py
+++ b/tofu/tests/tests01_geom/test00_Laura/test_LOS_west_geom.py
@@ -157,9 +157,9 @@ if __name__ == "__main__":
     # test_LOS_cprofiling()
     # plot_all_configs()
     # touch_plot_all_configs()
-    # touch_plot_config_cam("B1", "V100000")
-    touch_plot_config_cam("B2", "V100000")
-    # touch_plot_config_cam("B3", "V100000")
+    # touch_plot_config_cam("B3", "V10000")
+    #touch_plot_config_cam("B2", "V10000")
+    #touch_plot_config_cam("B3", "V100000")
     # line profiling.....
-    # test_line_profile(cam="V100000")
-    # print(test_LOS_west_configs("B2", ["V10000"]))
+    test_line_profile(cam="V1000")
+    # print(test_LOS_west_configs("B2", ["V10"]))
