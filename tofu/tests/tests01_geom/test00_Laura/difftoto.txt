diff --git a/tofu/geom/_GG02_LM.pyx b/tofu/geom/_GG02_LM.pyx
index 684faaa..20d416b 100644
--- a/tofu/geom/_GG02_LM.pyx
+++ b/tofu/geom/_GG02_LM.pyx
@@ -1,104 +1,101 @@
-# cython: boundscheck=False
-# cython: wraparound=False
-# cython: cdivision=True
-
+# cimport
 cimport cython
 cimport numpy as cnp
+from cpython cimport bool
 from libc.math cimport sqrt as Csqrt, ceil as Cceil, fabs as Cabs
 from libc.math cimport floor as Cfloor, log2 as Clog2
 from libc.math cimport cos as Ccos, acos as Cacos, sin as Csin, asin as Casin
 from libc.math cimport atan2 as Catan2, pi as Cpi
 from libc.math cimport NAN as Cnan
-from cpython.mem cimport PyMem_Malloc, PyMem_Free
+from libc.stdlib cimport malloc, free
 
 import numpy as np
+# from tofu.geom._poly_utils import get_bbox_poly_limited
+# from tofu.geom._poly_utils import get_bbox_poly_extruded
 
 
+__all__ = ['LOS_Calc_PInOut_VesStruct']
 
 cdef double _SMALL = 1.e-6
-cdef double _VERYSMALL = 1.e-9
-
-# =============================================================================
-# = Set of functions for Ray-tracing
-# =============================================================================
-
-def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
-                              double[:,::1] VPoly, double[:,::1] VIn,
-                              int ntotStruct=0, int nLim=-1,
-                              double[:] Lim=None,
+cdef double _VERY_SMALL = 1.e-9
+
+########################################################
+########################################################
+#       PIn POut
+########################################################
+
+# TODO : @LM > recall
+@cython.profile(True)
+@cython.linetrace(True)
+@cython.binding(True)
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds, double[:,::1] dus,
+                              double[:,::1] VPoly,
+                              double[:,::1] VIn,
+                              Lim=None, int nLim=<int>-1, int ntotStruct=<int>0,
                               list LSPoly=None, list LSLim=None,
                               list lSnLim=None, list LSVIn=None,
-                              double RMin=-1,
-                              double EpsUz=_SMALL,     double EpsA=_VERYSMALL,
-                              double EpsVz=_VERYSMALL, double EpsB=_VERYSMALL,
-                              double EpsPlane=_VERYSMALL,
-                              str VType='Tor',
-                              bint Forbid=1, bint Test=1):
-    """ 
-    Computes the entry and exit point of all provided LOS for the provided
-    vessel polygon (toroidal or linear) with its associated structures.
-    Return the normal vector at impact and the index of the impact segment
-    
-    Params
-    ======
-    Ds : (3, num_los) double array 
-       LOS origin points coordinates
-    us : (3, num_los) double array 
-       LOS normalized direction vector
-    VPoly : (2, num_vertex) double array
-       Coordinates of the vertices of the Polygon defining the 2D poloidal
-       cut of the Vessel
-    VIn : (2, num_vertex-1) double array
-       Normal vectors going "inwards" of the edges of the Polygon defined
-       by VPoly
-    nLim : int
-       Number of limits of the vessel
-           -1 : no limits, vessel continuous all around
-            1 : vessel is limited
-    Lim : array
-       If nLim==1 contains the limits min and max of vessel
-    ntotStruc : int
-       Total number of structures (counting each limited structure as one)
-    LSPoly : list
-       List of coordinates of the vertices of all structures on poloidal plane
-    LSLim : list
-       List of limits of all structures
-    LSnLim : list
-       List of number of limits for all structures
-    LSVIn : list
-       List of coordinates of "inwards" normal vectors of the polygon of all
-       the structures
-    RMin : double
-       Minimal radius of vessel to take into consideration
-    Eps<val> : double
-       Small value, acceptance of error
-    Vtype : string
-       Type of vessel ("Tor" or "Lin")
-    Forbid : bool
-       Should we forbid values behind vissible radius ? (see Rmin)
-    Test : bool
-       Should we run tests ?
-   
+                              RMin=None, bool Forbid=True,
+                              double EpsUz=_SMALL,
+                              double EpsVz=_VERY_SMALL,
+                              double EpsA=_VERY_SMALL,
+                              double EpsB=_VERY_SMALL,
+                              double EpsPlane=_VERY_SMALL,
+                              str VType='Tor', bool Test=True):
+    """ Compute the entry and exit point of all provided LOS for the provided
+    vessel polygon (toroidal or linear), also return the normal vector at
+    impact point and the index of the impact segment
+
+    For each LOS,
+
+    Parameters
+    ----------
+
+
+
     Return
-    ======
-    kPIn : (num_los) array
-       scalars defining level of "in" intersection of the LOS (if k=0 at origin)
-    kPOut : (num_los) array
-       scalars defining level of "out" intersection of the LOS (if k=0 at origin)
-    VperpOut : (3, num_los) array
-       Coordinates of the normal vector of impact of the LOS (NaN if none)
-    IOut : (3, num_los)
-       Index of structure impacted by LOS: IOut[:,ind_los]=(i,j,k) where k is
-       the index of edge impacted on the j-th sub structure of the structure
-       number i. If the LOS impacted the vessel i=j=0
-    """
+    ------
+    PIn :       np.ndarray
+        Point of entry (if any) of the LOS into the vessel, returned in (X,Y,Z)
+        cartesian coordinates as:
+            1 LOS => (3,) array or None if there is no entry point
+            NL LOS => (3,NL), with NaNs when there is no entry point
+    POut :      np.ndarray
+        Point of exit of the LOS from the vessel, returned in (X,Y,Z) cartesian
+        coordinates as:
+            1 LOS => (3,) array or None if there is no entry point
+            NL LOS => (3,NL), with NaNs when there is no entry point
+    VOut :      np.ndarray
+
+    IOut :      np.ndarray
 
-    cdef int ii, jj
+    """
+    if Test:
+        assert tuple(Ds.shape)==tuple(dus.shape) and \
+            Ds.shape[0]==3, (
+                "Args Ds and dus must be of the same shape (3,) or (3,NL)!")
+        assert VPoly.shape[0]==2 and VIn.shape[0]==2 and \
+            VIn.shape[1]==VPoly.shape[1]-1, (
+                "Args VPoly and VIn must be of the same shape (2,NS)!")
+        C1 = all([pp is None for pp in [LSPoly,LSLim,LSVIn]])
+        C2 = all([hasattr(pp,'__iter__') and len(pp)==len(LSPoly) for pp
+                  in [LSPoly,LSLim,LSVIn]])
+        assert C1 or C2, "Args LSPoly,LSLim,LSVIn must be None or lists of same len()!"
+        assert RMin is None or type(RMin) in [float,int,np.float64,np.int64], (
+            "Arg RMin must be None or a float!")
+        assert all([type(ee) in [int,float,np.int64,np.float64] and ee<1.e-4
+                    for ee in [EpsUz,EpsVz,EpsA,EpsB,EpsPlane]]), \
+                        "Args [EpsUz,EpsVz,EpsA,EpsB] must be floats < 1.e-4!"
+        assert VType.lower() in ['tor','lin'], (
+            "Arg VType must be a str in ['Tor','Lin']!")
+
+    cdef int ii, jj, iloc
     cdef int ind_lim_data = 0
     cdef int len_lspoly
     cdef bint found_new_kout
     cdef bint lim_is_none=1
-    cdef bint bool1, bool2
     cdef double val_rmin
     cdef double kpin_jj
     cdef double kpout_jj
@@ -122,37 +119,22 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
     cdef double[3] invr_ray
     cdef int[3] sign_ray
     cdef int[1] indin_loc
-    cdef str error_message
 
-    if Test:
-        error_message = "Args Ds and dus must be of the same shape: (3,) or (3,NL)!"
-        assert tuple(Ds.shape)==tuple(dus.shape) and \
-            Ds.shape[0]==3, error_message
-        error_message = "Args VPoly and VIn must be of the same shape (2,NS)!"
-        assert VPoly.shape[0]==2 and VIn.shape[0]==2 and \
-            VIn.shape[1]==VPoly.shape[1]-1, error_message
-        bool1 = LSLim is None or len(LSLim) == len(LSPoly)
-        bool2 = LSVIn is None or len(LSVIn) == len(LSPoly)
-        error_message = "Args LSPoly,LSLim,LSVIn must be None or lists of same len()!"
-        assert bool1 and bool2, error_message
-        error_message = "Args [EpsUz,EpsVz,EpsA,EpsB] must be floats < 1.e-4!"
-        assert all([ee<1.e-4 for ee in [EpsUz,EpsVz,EpsA,EpsB,EpsPlane]]), error_message
-        error_message = "Arg VType must be a str in ['Tor','Lin']!"
-        assert VType.lower() in ['tor','lin'], error_message
-
-    cdef double *VperpOut = <double *>PyMem_Malloc(3 * num_los * sizeof(double))
-    cdef double *kPIn  = <double *>PyMem_Malloc(num_los * sizeof(double))
-    cdef double *kPOut = <double *>PyMem_Malloc(num_los * sizeof(double))
-    cdef long *IOut = <long *>PyMem_Malloc(3 * num_los * sizeof(long))
-
-    cdef double[:] VperpOut_view = <double[:num_los*3]> VperpOut
-    cdef double[:] kPIn_view  = <double[:num_los]>kPIn
+    VperpOut  = np.zeros((3, num_los), dtype=np.double)
+    # kPIn      = np.zeros((num_los,),   dtype=np.double)
+    # kPOut     = np.zeros((num_los,),   dtype=np.double)
+    IOut      = np.zeros((3, num_los), dtype=int)
+    cdef double *kPIn  = <double *>malloc(num_los * sizeof(double))
+    cdef double *kPOut = <double *>malloc(num_los * sizeof(double))
+
+    cdef double[:, ::1] VperpOut_view = VperpOut
+    cdef double[:] kPIn_view = <double[:num_los]>kPIn
     cdef double[:] kPOut_view = <double[:num_los]>kPOut
-    cdef long[:]   IOut_view  = <long[:3*num_los]>IOut
+    cdef long[:, ::1] IOut_view = IOut
 
     llim_ves = []
-    cdef double *lbounds = <double *>PyMem_Malloc(ntotStruct * 6 * sizeof(double))
-    cdef double *langles = <double *>PyMem_Malloc(ntotStruct * 2 * sizeof(double))
+    cdef double *lbounds = <double *>malloc(ntotStruct * 6 * sizeof(double))
+    cdef double *langles = <double *>malloc(ntotStruct * 2 * sizeof(double))
     cdef long *llen_lim
     cdef double[:,::1] lspoly_view
     cdef int nvert
@@ -161,8 +143,8 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
         lim_is_none = 1
     elif nLim==1:
         lim_is_none = 0
-        lim_ves[0] = Lim[0]
-        lim_ves[1] = Lim[1]
+        lim_ves[0] = Lim[0,0]
+        lim_ves[1] = Lim[0,1]
         L0 = Catan2(Csin(lim_ves[0]),Ccos(lim_ves[0]))
         L1 = Catan2(Csin(lim_ves[1]),Ccos(lim_ves[1]))
     if lSnLim is not None:
@@ -174,13 +156,15 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
 
     if VType.lower()=='tor':
         # RMin is necessary to avoid looking on the other side of the tokamak
-        if RMin < 0.:
+        if RMin is None:
             val_rmin = <double>0.95*min(np.min(VPoly[0,...]),
                             np.min(np.hypot(Ds[0,...],Ds[1,...])))
+        else:
+            val_rmin = <double>RMin
         # Main function to compute intersections with Vessel
         Calc_LOS_PInOut_Tor(Ds, dus, VPoly, VIn, kPIn_view,
                             kPOut_view, VperpOut_view, IOut_view,
-                            num_los, val_rmin,
+                            val_rmin,
                             lim_is_none, L0, L1,
                             Forbid=Forbid,
                             EpsUz=EpsUz, EpsVz=EpsVz,
@@ -192,7 +176,7 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
         if LSPoly is not None:
             ind_lim_data = 0
             len_lspoly = len(LSPoly)
-            llen_lim  = <long *>PyMem_Malloc(len_lspoly * sizeof(long))
+            llen_lim  = <long *>malloc(len_lspoly * sizeof(long))
             for ii in range(len_lspoly):
                 if LSLim[ii] is None or not all([hasattr(ll,'__iter__') for ll in LSLim[ii]]):
                     lslim = [LSLim[ii]]
@@ -215,7 +199,7 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
                         compute_bbox_lim(nvert, lspoly_view, bounds, L0, L1)
                     else:
                         llim_ves.append(1)
-                        compute_bbox_extr(nvert, lspoly_view, bounds)
+                        compute_bbox2(nvert, lspoly_view, bounds)
                         L0 = 0.
                         L1 = 0.
                     langles[ind_lim_data*2] = L0
@@ -229,7 +213,9 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
                 # We get the last kpout:
                 kpout_jj = kPOut_view[ind_tmp]
                 kpin_loc[0] = kpout_jj
-                indin_loc[0] = IOut_view[2+3*ind_tmp]
+                indin_loc[0] = IOut_view[2,ind_tmp]
+                # if ind_tmp == 0:
+                #     IOut_view[2, ind_tmp] = IOut2_view[ind_tmp]
                 los_orig_loc[0] = Ds[0, ind_tmp]
                 los_orig_loc[1] = Ds[1, ind_tmp]
                 los_orig_loc[2] = Ds[2, ind_tmp]
@@ -306,23 +292,27 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
                                                               EpsPlane, False)
                         if found_new_kout :
                             kPOut_view[ind_tmp] = kpin_loc[0]
-                            VperpOut_view[0+3*ind_tmp] = struct_vperpin_view[0]
-                            VperpOut_view[1+3*ind_tmp] = struct_vperpin_view[1]
-                            VperpOut_view[2+3*ind_tmp] = struct_vperpin_view[2]
-                            IOut_view[2+3*ind_tmp] = indin_loc[0]
-                            IOut_view[0+3*ind_tmp] = 1+ii
-                            IOut_view[1+3*ind_tmp] = jj
+                            VperpOut_view[0,ind_tmp] = struct_vperpin_view[0]
+                            VperpOut_view[1,ind_tmp] = struct_vperpin_view[1]
+                            VperpOut_view[2,ind_tmp] = struct_vperpin_view[2]
+                            IOut_view[2,ind_tmp] = indin_loc[0]
+                            IOut_view[0,ind_tmp] = 1+ii
+                            IOut_view[1,ind_tmp] = jj
                             last_pout[0] = kPOut_view[ind_tmp] * los_dirv_loc[0] + los_orig_loc[0]
                             last_pout[1] = kPOut_view[ind_tmp] * los_dirv_loc[1] + los_orig_loc[1]
                             last_pout[2] = kPOut_view[ind_tmp] * los_dirv_loc[2] + los_orig_loc[2]
 
-            PyMem_Free(llen_lim)
-    PyMem_Free(lbounds)
-    PyMem_Free(langles)
-    return np.asarray(kPIn_view), np.asarray(kPOut_view),\
-      np.asarray(VperpOut_view),\
-      np.asarray(IOut_view)
-
+            free(llen_lim)
+    free(lbounds)
+    free(langles)
+    return np.asarray(kPIn_view), np.asarray(kPOut_view), VperpOut, IOut
+
+@cython.profile(True)
+@cython.linetrace(True)
+@cython.binding(True)
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                                 double [:,::1] VPoly, double [:,::1] vIn,
                                 int vin_shape,
@@ -366,6 +356,7 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
             # segment (i.e.: cone, not plane)
             # TODO : @LM : is this faster than checking abs(diff)>eps ?
             if (VPoly[1,jj+1] - VPoly[1,jj])**2 > EpsVz*EpsVz:
+                # TODO : @LM this probably can done matrix wise (qmatrix)
                 q = (Ds[2]-VPoly[1,jj]) / (VPoly[1,jj+1]-VPoly[1,jj])
                 # The intersection must stand on the segment
                 if q>=0 and q<1:
@@ -379,6 +370,8 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                         # (i.e.: k>=0)
                         # First solution
                         if -upscaDp - sqd >=0:
+                            # TODO : @LM - est-ce que c'est possible de le mat ?
+                            # ou le sortir d'ici
                             k = (-upscaDp - sqd)*invupar2
                             sol0, sol1 = Ds[0] + k*us[0], \
                                          Ds[1] + k*us[1]
@@ -546,15 +539,15 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                                     #print(10, k, q, A, B, C, sqd, v0, v1, jj)
 
     if not lim_is_none:
-        ephiIn0 = -sinl0
-        ephiIn1 =  cosl0
+        ephiIn0, ephiIn1 = -sinl0, cosl0
         if Cabs(us[0]*ephiIn0+us[1]*ephiIn1)>EpsPlane:
             k = -(Ds[0]*ephiIn0+Ds[1]*ephiIn1)/(us[0]*ephiIn0+us[1]*ephiIn1)
             if k>=0:
                 # Check if in VPoly
-                sol0 = (Ds[0] + k*us[0]) * cosl0 + (Ds[1] + k*us[1]) * sinl0
-                sol1 =  Ds[2] + k*us[2]
-                inter_bbox = is_point_in_path(vin_shape, VPoly[0,...], VPoly[1,...], sol0, sol1)
+                sol0, sol1 = (Ds[0]+k*us[0])*cosl0 + (Ds[1]+k*us[1])*sinl0, Ds[2]+k*us[2]
+                #if path_poly_t.contains_point([sol0,sol1], transform=None, radius=0.0):
+                #if ray_tracing(VPoly, sol0, sol1):
+                inter_bbox = pnpoly(vin_shape, VPoly[0,...], VPoly[1,...], sol0, sol1)
                 if inter_bbox:
                     # Check PIn (POut not possible for limited torus)
                     sca = us[0]*ephiIn0 + us[1]*ephiIn1
@@ -566,8 +559,7 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                         kin = k
                         indin = -1
 
-        ephiIn0 =  sinl1
-        ephiIn1 = -cosl1
+        ephiIn0, ephiIn1 = sinl1, -cosl1
         if Cabs(us[0]*ephiIn0+us[1]*ephiIn1)>EpsPlane:
             k = -(Ds[0]*ephiIn0+Ds[1]*ephiIn1)/(us[0]*ephiIn0+us[1]*ephiIn1)
             if k>=0:
@@ -575,7 +567,7 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                 # Check if in VPoly
                 #if path_poly_t.contains_point([sol0,sol1], transform=None, radius=0.0):
                 # if ray_tracing(VPoly, sol0, sol1):
-                inter_bbox = is_point_in_path(vin_shape, VPoly[0,...], VPoly[1,...], sol0, sol1)
+                inter_bbox = pnpoly(vin_shape, VPoly[0,...], VPoly[1,...], sol0, sol1)
                 if inter_bbox:
                     # Check PIn (POut not possible for limited torus)
                     sca = us[0]*ephiIn0 + us[1]*ephiIn1
@@ -632,13 +624,19 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                 
     return res_kin != kpin_loc[0]
 
+# et creer vecteurs
+#    return np.asarray(kIn), np.asarray(kOut), np.asarray(vPerpOut), np.asarray(indOut)
+
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline void compute_inv_and_sign(const double[3] us,
                                       int[3] sign,
                                       double[3] inv_direction) nogil:
     cdef int t0 = 1000000
     # computing sign and direction
     for  ii in range(3):
-        if us[ii]*us[ii] < _VERYSMALL:
+        if us[ii]*us[ii] < _VERY_SMALL:
             inv_direction[ii] = t0
         else:
             inv_direction[ii] = 1./us[ii]
@@ -649,6 +647,9 @@ cdef inline void compute_inv_and_sign(const double[3] us,
 
     return
 
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline bint ray_intersects_abba_bbox(const int[3] sign,
                                           const double[3] inv_direction,
                                           const double[6] bounds,
@@ -690,7 +691,11 @@ cdef inline bint ray_intersects_abba_bbox(const int[3] sign,
     return  res
 
 
-cdef inline bint is_point_in_path(int nvert, double[:] vertx, double[:] verty, double testx, double testy) nogil:
+
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cdef inline bint pnpoly(int nvert, double[:] vertx, double[:] verty, double testx, double testy) nogil:
     cdef int i
     cdef bint c = 0
     for i in range(nvert):
@@ -699,17 +704,19 @@ cdef inline bint is_point_in_path(int nvert, double[:] vertx, double[:] verty, d
             c = not c
     return c
 
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline void Calc_LOS_PInOut_Tor(double [:,::1] Ds, double [:,::1] us,
-                                     double [:,::1] VPoly, double [:,::1] vIn,
-                                     double[:] kPIn_view, double[:] kPOut_view,
-                                     double[:] VperpOut_view, long[:] IOut_view,
-                                     int Nl,
-                                     double Rmin, bint lim_is_none, double L0, double L1,
-                                     bint Forbid,  double EpsUz,
-                                     double EpsVz, double EpsA,
-                                     double EpsB,  double EpsPlane):
-
-    cdef int ii, jj, Ns=vIn.shape[1]
+                         double [:,::1] VPoly, double [:,::1] vIn,
+                         double[:] kPIn_view, double[:] kPOut_view,
+                         double[:,::1] VperpOut_view, long[:,::1] IOut_view,
+                         double Rmin, bint lim_is_none, double L0, double L1,
+                         bint Forbid, double EpsUz,
+                         double EpsVz, double EpsA,
+                         double EpsB, double EpsPlane):
+
+    cdef int ii, jj, Nl=Ds.shape[1], Ns=vIn.shape[1]
     cdef double upscaDp, upar2, Dpar2, Crit2, kout, kin, invDpar2
     cdef int indout=0, Done=0
     cdef double L=0., S1X=0., S1Y=0., S2X=0., S2Y=0., sca=0., sca0=0., sca1=0., sca2=0.
@@ -738,9 +745,9 @@ cdef inline void Calc_LOS_PInOut_Tor(double [:,::1] Ds, double [:,::1] us,
         loc_ds[0] = Ds[0,ii]
         loc_ds[1] = Ds[1,ii]
         loc_ds[2] = Ds[2,ii]
-        loc_vp[0] = VperpOut_view[0+3*ii]
-        loc_vp[1] = VperpOut_view[1+3*ii]
-        loc_vp[2] = VperpOut_view[2+3*ii]
+        loc_vp[0] = VperpOut_view[0,ii]
+        loc_vp[1] = VperpOut_view[1,ii]
+        loc_vp[2] = VperpOut_view[2,ii]
         upscaDp = loc_us[0]*loc_ds[0] + loc_us[1]*loc_ds[1]
         upar2 = loc_us[0]*loc_us[0] + loc_us[1]*loc_us[1]
         Dpar2 = loc_ds[0]*loc_ds[0] + loc_ds[1]*loc_ds[1]
@@ -764,38 +771,65 @@ cdef inline void Calc_LOS_PInOut_Tor(double [:,::1] Ds, double [:,::1] us,
         Crit2 = upar2*Crit2_base
         kpin_loc[0]  = kPIn_view[ii]
         kpout_loc[0] = kPOut_view[ii]
-        indout_loc[0] = IOut_view[2 + 3*ii]
+        indout_loc[0] = IOut_view[2, ii]
         found_new = comp_inter_los_vpoly(loc_ds, loc_us, VPoly, vIn, Ns, lim_is_none,
                                          L0, L1, kpin_loc, kpout_loc, indout_loc, loc_vp,
                                          Forbidbis, upscaDp, upar2, Dpar2, invDpar2,
                                          S1X, S1Y, S2X, S2Y, Crit2, EpsUz, EpsVz, EpsA, EpsB,
                                          EpsPlane, True)
         if found_new:
-            kPIn_view[ii]         = kpin_loc[0]
-            kPOut_view[ii]        = kpout_loc[0]
-            IOut_view[2+3*ii]     = indout_loc[0]
-            IOut_view[0+3*ii]     = 0
-            IOut_view[1+3*ii]     = 0
-            VperpOut_view[0+3*ii] = loc_vp[0]
-            VperpOut_view[1+3*ii] = loc_vp[1]
-            VperpOut_view[2+3*ii] = loc_vp[2]
+            kPIn_view[ii]       = kpin_loc[0]
+            kPOut_view[ii]      = kpout_loc[0]
+            IOut_view[2, ii]    = indout_loc[0]
+            IOut_view[0, ii]    = 0
+            IOut_view[1, ii]    = 0
+            VperpOut_view[0,ii] = loc_vp[0]
+            VperpOut_view[1,ii] = loc_vp[1]
+            VperpOut_view[2,ii] = loc_vp[2]
 
         else:
-            kPIn_view[ii]         = Cnan
-            kPOut_view[ii]        = Cnan
-            IOut_view[2+3*ii]     = -1000000
-            IOut_view[0+3*ii]     = 0
-            IOut_view[1+3*ii]     = 0
-            VperpOut_view[0+3*ii] = Cnan
-            VperpOut_view[1+3*ii] = Cnan
-            VperpOut_view[2+3*ii] = Cnan
+            kPIn_view[ii]       = Cnan
+            kPOut_view[ii]      = Cnan
+            IOut_view[2, ii]    = -1000000
+            IOut_view[0, ii]    = 0
+            IOut_view[1, ii]    = 0
+            VperpOut_view[0,ii] = Cnan
+            VperpOut_view[1,ii] = Cnan
+            VperpOut_view[2,ii] = Cnan
+            
 
     return
 
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cdef inline void compute_bbox(int nvert, double[:] vertr, double[:] vertz,
+       double[6] bounds):
+    cdef int ii
+    cdef double rmax=vertr[0], zmin=vertz[0], zmax=vertz[0]
+    cdef double tmp_val
+    for ii in range(1, nvert):
+        tmp_val = vertr[ii]
+        if tmp_val > rmax:
+            rmax = tmp_val
+        tmp_val = vertz[ii]
+        if tmp_val > zmax:
+            zmax = tmp_val
+        elif tmp_val < zmin:
+            zmin = tmp_val
+    bounds[0] = -rmax
+    bounds[1] = -rmax
+    bounds[2] = zmin
+    bounds[3] = rmax
+    bounds[4] = rmax
+    bounds[5] = zmax
+    return
 
-
-cdef inline void compute_bbox_extr(int nvert, double[:,::1] vert,
-                                   double[6] bounds) nogil:
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cdef inline void compute_bbox2(int nvert, double[:,::1] vert,
+       double[6] bounds) nogil:
     cdef int ii
     cdef double rmax=vert[0,0], zmin=vert[1,0], zmax=vert[1,0]
     cdef double tmp_val
@@ -816,7 +850,9 @@ cdef inline void compute_bbox_extr(int nvert, double[:,::1] vert,
     bounds[5] = zmax
     return
 
-
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline void compute_bbox_lim(int nvert, double[:,::1] vert,
                                   double[6] bounds, double lmin, double lmax) nogil:
     cdef int ii
@@ -873,7 +909,53 @@ cdef inline void compute_bbox_lim(int nvert, double[:,::1] vert,
     return
 
 
+cdef inline void coordshift_simple(double[:,::1] pts, bool in_is_cartesian=True,
+                       double CrossRef=0., double cos_phi=0., double sin_phi=0.):
 
+    cdef int npts = pts.shape[1]
+    cdef int ii
+    cdef double x, y, z
+    cdef double r, p
+    if in_is_cartesian:
+        if CrossRef==0.:
+            for ii in range(npts):
+                x = pts[0, ii]
+                y = pts[1, ii]
+                z = pts[2, ii]
+                pts[0, ii] = Csqrt(x*x+y*y)
+                pts[1, ii] = z
+                pts[2, ii] = Catan2(y,x)
+        else:
+            for ii in range(npts):
+                x = pts[0, ii]
+                y = pts[1, ii]
+                z = pts[2, ii]
+                pts[0, ii] = Csqrt(x*x+y*y)
+                pts[1, ii] = z
+                pts[2, ii] = CrossRef
+
+    else:
+        if CrossRef==0.:
+            for ii in range(npts):
+                r = pts[0, ii]
+                z = pts[1, ii]
+                p = pts[2, ii]
+                pts[0, ii] = r*Ccos(p)
+                pts[1, ii] = r*Csin(p)
+                pts[2, ii] = z
+        else:
+            for ii in range(npts):
+                r = pts[0, ii]
+                z = pts[1, ii]
+                pts[0, ii] = r*cos_phi
+                pts[1, ii] = r*sin_phi
+                pts[2, ii] = z
+    return
+
+
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline void coordshift_simple1d(double[3] pts, bint in_is_cartesian=True,
                                      double CrossRef=0., double cos_phi=0.,
                                      double sin_phi=0.) nogil:
@@ -911,4 +993,3 @@ cdef inline void coordshift_simple1d(double[3] pts, bint in_is_cartesian=True,
             pts[2] = z
     return
 
-
diff --git a/tofu/geom/_GG03_LM.pyx b/tofu/geom/_GG03_LM.pyx
index 684faaa..20d416b 100644
--- a/tofu/geom/_GG03_LM.pyx
+++ b/tofu/geom/_GG03_LM.pyx
@@ -1,104 +1,101 @@
-# cython: boundscheck=False
-# cython: wraparound=False
-# cython: cdivision=True
-
+# cimport
 cimport cython
 cimport numpy as cnp
+from cpython cimport bool
 from libc.math cimport sqrt as Csqrt, ceil as Cceil, fabs as Cabs
 from libc.math cimport floor as Cfloor, log2 as Clog2
 from libc.math cimport cos as Ccos, acos as Cacos, sin as Csin, asin as Casin
 from libc.math cimport atan2 as Catan2, pi as Cpi
 from libc.math cimport NAN as Cnan
-from cpython.mem cimport PyMem_Malloc, PyMem_Free
+from libc.stdlib cimport malloc, free
 
 import numpy as np
+# from tofu.geom._poly_utils import get_bbox_poly_limited
+# from tofu.geom._poly_utils import get_bbox_poly_extruded
 
 
+__all__ = ['LOS_Calc_PInOut_VesStruct']
 
 cdef double _SMALL = 1.e-6
-cdef double _VERYSMALL = 1.e-9
-
-# =============================================================================
-# = Set of functions for Ray-tracing
-# =============================================================================
-
-def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
-                              double[:,::1] VPoly, double[:,::1] VIn,
-                              int ntotStruct=0, int nLim=-1,
-                              double[:] Lim=None,
+cdef double _VERY_SMALL = 1.e-9
+
+########################################################
+########################################################
+#       PIn POut
+########################################################
+
+# TODO : @LM > recall
+@cython.profile(True)
+@cython.linetrace(True)
+@cython.binding(True)
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds, double[:,::1] dus,
+                              double[:,::1] VPoly,
+                              double[:,::1] VIn,
+                              Lim=None, int nLim=<int>-1, int ntotStruct=<int>0,
                               list LSPoly=None, list LSLim=None,
                               list lSnLim=None, list LSVIn=None,
-                              double RMin=-1,
-                              double EpsUz=_SMALL,     double EpsA=_VERYSMALL,
-                              double EpsVz=_VERYSMALL, double EpsB=_VERYSMALL,
-                              double EpsPlane=_VERYSMALL,
-                              str VType='Tor',
-                              bint Forbid=1, bint Test=1):
-    """ 
-    Computes the entry and exit point of all provided LOS for the provided
-    vessel polygon (toroidal or linear) with its associated structures.
-    Return the normal vector at impact and the index of the impact segment
-    
-    Params
-    ======
-    Ds : (3, num_los) double array 
-       LOS origin points coordinates
-    us : (3, num_los) double array 
-       LOS normalized direction vector
-    VPoly : (2, num_vertex) double array
-       Coordinates of the vertices of the Polygon defining the 2D poloidal
-       cut of the Vessel
-    VIn : (2, num_vertex-1) double array
-       Normal vectors going "inwards" of the edges of the Polygon defined
-       by VPoly
-    nLim : int
-       Number of limits of the vessel
-           -1 : no limits, vessel continuous all around
-            1 : vessel is limited
-    Lim : array
-       If nLim==1 contains the limits min and max of vessel
-    ntotStruc : int
-       Total number of structures (counting each limited structure as one)
-    LSPoly : list
-       List of coordinates of the vertices of all structures on poloidal plane
-    LSLim : list
-       List of limits of all structures
-    LSnLim : list
-       List of number of limits for all structures
-    LSVIn : list
-       List of coordinates of "inwards" normal vectors of the polygon of all
-       the structures
-    RMin : double
-       Minimal radius of vessel to take into consideration
-    Eps<val> : double
-       Small value, acceptance of error
-    Vtype : string
-       Type of vessel ("Tor" or "Lin")
-    Forbid : bool
-       Should we forbid values behind vissible radius ? (see Rmin)
-    Test : bool
-       Should we run tests ?
-   
+                              RMin=None, bool Forbid=True,
+                              double EpsUz=_SMALL,
+                              double EpsVz=_VERY_SMALL,
+                              double EpsA=_VERY_SMALL,
+                              double EpsB=_VERY_SMALL,
+                              double EpsPlane=_VERY_SMALL,
+                              str VType='Tor', bool Test=True):
+    """ Compute the entry and exit point of all provided LOS for the provided
+    vessel polygon (toroidal or linear), also return the normal vector at
+    impact point and the index of the impact segment
+
+    For each LOS,
+
+    Parameters
+    ----------
+
+
+
     Return
-    ======
-    kPIn : (num_los) array
-       scalars defining level of "in" intersection of the LOS (if k=0 at origin)
-    kPOut : (num_los) array
-       scalars defining level of "out" intersection of the LOS (if k=0 at origin)
-    VperpOut : (3, num_los) array
-       Coordinates of the normal vector of impact of the LOS (NaN if none)
-    IOut : (3, num_los)
-       Index of structure impacted by LOS: IOut[:,ind_los]=(i,j,k) where k is
-       the index of edge impacted on the j-th sub structure of the structure
-       number i. If the LOS impacted the vessel i=j=0
-    """
+    ------
+    PIn :       np.ndarray
+        Point of entry (if any) of the LOS into the vessel, returned in (X,Y,Z)
+        cartesian coordinates as:
+            1 LOS => (3,) array or None if there is no entry point
+            NL LOS => (3,NL), with NaNs when there is no entry point
+    POut :      np.ndarray
+        Point of exit of the LOS from the vessel, returned in (X,Y,Z) cartesian
+        coordinates as:
+            1 LOS => (3,) array or None if there is no entry point
+            NL LOS => (3,NL), with NaNs when there is no entry point
+    VOut :      np.ndarray
+
+    IOut :      np.ndarray
 
-    cdef int ii, jj
+    """
+    if Test:
+        assert tuple(Ds.shape)==tuple(dus.shape) and \
+            Ds.shape[0]==3, (
+                "Args Ds and dus must be of the same shape (3,) or (3,NL)!")
+        assert VPoly.shape[0]==2 and VIn.shape[0]==2 and \
+            VIn.shape[1]==VPoly.shape[1]-1, (
+                "Args VPoly and VIn must be of the same shape (2,NS)!")
+        C1 = all([pp is None for pp in [LSPoly,LSLim,LSVIn]])
+        C2 = all([hasattr(pp,'__iter__') and len(pp)==len(LSPoly) for pp
+                  in [LSPoly,LSLim,LSVIn]])
+        assert C1 or C2, "Args LSPoly,LSLim,LSVIn must be None or lists of same len()!"
+        assert RMin is None or type(RMin) in [float,int,np.float64,np.int64], (
+            "Arg RMin must be None or a float!")
+        assert all([type(ee) in [int,float,np.int64,np.float64] and ee<1.e-4
+                    for ee in [EpsUz,EpsVz,EpsA,EpsB,EpsPlane]]), \
+                        "Args [EpsUz,EpsVz,EpsA,EpsB] must be floats < 1.e-4!"
+        assert VType.lower() in ['tor','lin'], (
+            "Arg VType must be a str in ['Tor','Lin']!")
+
+    cdef int ii, jj, iloc
     cdef int ind_lim_data = 0
     cdef int len_lspoly
     cdef bint found_new_kout
     cdef bint lim_is_none=1
-    cdef bint bool1, bool2
     cdef double val_rmin
     cdef double kpin_jj
     cdef double kpout_jj
@@ -122,37 +119,22 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
     cdef double[3] invr_ray
     cdef int[3] sign_ray
     cdef int[1] indin_loc
-    cdef str error_message
 
-    if Test:
-        error_message = "Args Ds and dus must be of the same shape: (3,) or (3,NL)!"
-        assert tuple(Ds.shape)==tuple(dus.shape) and \
-            Ds.shape[0]==3, error_message
-        error_message = "Args VPoly and VIn must be of the same shape (2,NS)!"
-        assert VPoly.shape[0]==2 and VIn.shape[0]==2 and \
-            VIn.shape[1]==VPoly.shape[1]-1, error_message
-        bool1 = LSLim is None or len(LSLim) == len(LSPoly)
-        bool2 = LSVIn is None or len(LSVIn) == len(LSPoly)
-        error_message = "Args LSPoly,LSLim,LSVIn must be None or lists of same len()!"
-        assert bool1 and bool2, error_message
-        error_message = "Args [EpsUz,EpsVz,EpsA,EpsB] must be floats < 1.e-4!"
-        assert all([ee<1.e-4 for ee in [EpsUz,EpsVz,EpsA,EpsB,EpsPlane]]), error_message
-        error_message = "Arg VType must be a str in ['Tor','Lin']!"
-        assert VType.lower() in ['tor','lin'], error_message
-
-    cdef double *VperpOut = <double *>PyMem_Malloc(3 * num_los * sizeof(double))
-    cdef double *kPIn  = <double *>PyMem_Malloc(num_los * sizeof(double))
-    cdef double *kPOut = <double *>PyMem_Malloc(num_los * sizeof(double))
-    cdef long *IOut = <long *>PyMem_Malloc(3 * num_los * sizeof(long))
-
-    cdef double[:] VperpOut_view = <double[:num_los*3]> VperpOut
-    cdef double[:] kPIn_view  = <double[:num_los]>kPIn
+    VperpOut  = np.zeros((3, num_los), dtype=np.double)
+    # kPIn      = np.zeros((num_los,),   dtype=np.double)
+    # kPOut     = np.zeros((num_los,),   dtype=np.double)
+    IOut      = np.zeros((3, num_los), dtype=int)
+    cdef double *kPIn  = <double *>malloc(num_los * sizeof(double))
+    cdef double *kPOut = <double *>malloc(num_los * sizeof(double))
+
+    cdef double[:, ::1] VperpOut_view = VperpOut
+    cdef double[:] kPIn_view = <double[:num_los]>kPIn
     cdef double[:] kPOut_view = <double[:num_los]>kPOut
-    cdef long[:]   IOut_view  = <long[:3*num_los]>IOut
+    cdef long[:, ::1] IOut_view = IOut
 
     llim_ves = []
-    cdef double *lbounds = <double *>PyMem_Malloc(ntotStruct * 6 * sizeof(double))
-    cdef double *langles = <double *>PyMem_Malloc(ntotStruct * 2 * sizeof(double))
+    cdef double *lbounds = <double *>malloc(ntotStruct * 6 * sizeof(double))
+    cdef double *langles = <double *>malloc(ntotStruct * 2 * sizeof(double))
     cdef long *llen_lim
     cdef double[:,::1] lspoly_view
     cdef int nvert
@@ -161,8 +143,8 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
         lim_is_none = 1
     elif nLim==1:
         lim_is_none = 0
-        lim_ves[0] = Lim[0]
-        lim_ves[1] = Lim[1]
+        lim_ves[0] = Lim[0,0]
+        lim_ves[1] = Lim[0,1]
         L0 = Catan2(Csin(lim_ves[0]),Ccos(lim_ves[0]))
         L1 = Catan2(Csin(lim_ves[1]),Ccos(lim_ves[1]))
     if lSnLim is not None:
@@ -174,13 +156,15 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
 
     if VType.lower()=='tor':
         # RMin is necessary to avoid looking on the other side of the tokamak
-        if RMin < 0.:
+        if RMin is None:
             val_rmin = <double>0.95*min(np.min(VPoly[0,...]),
                             np.min(np.hypot(Ds[0,...],Ds[1,...])))
+        else:
+            val_rmin = <double>RMin
         # Main function to compute intersections with Vessel
         Calc_LOS_PInOut_Tor(Ds, dus, VPoly, VIn, kPIn_view,
                             kPOut_view, VperpOut_view, IOut_view,
-                            num_los, val_rmin,
+                            val_rmin,
                             lim_is_none, L0, L1,
                             Forbid=Forbid,
                             EpsUz=EpsUz, EpsVz=EpsVz,
@@ -192,7 +176,7 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
         if LSPoly is not None:
             ind_lim_data = 0
             len_lspoly = len(LSPoly)
-            llen_lim  = <long *>PyMem_Malloc(len_lspoly * sizeof(long))
+            llen_lim  = <long *>malloc(len_lspoly * sizeof(long))
             for ii in range(len_lspoly):
                 if LSLim[ii] is None or not all([hasattr(ll,'__iter__') for ll in LSLim[ii]]):
                     lslim = [LSLim[ii]]
@@ -215,7 +199,7 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
                         compute_bbox_lim(nvert, lspoly_view, bounds, L0, L1)
                     else:
                         llim_ves.append(1)
-                        compute_bbox_extr(nvert, lspoly_view, bounds)
+                        compute_bbox2(nvert, lspoly_view, bounds)
                         L0 = 0.
                         L1 = 0.
                     langles[ind_lim_data*2] = L0
@@ -229,7 +213,9 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
                 # We get the last kpout:
                 kpout_jj = kPOut_view[ind_tmp]
                 kpin_loc[0] = kpout_jj
-                indin_loc[0] = IOut_view[2+3*ind_tmp]
+                indin_loc[0] = IOut_view[2,ind_tmp]
+                # if ind_tmp == 0:
+                #     IOut_view[2, ind_tmp] = IOut2_view[ind_tmp]
                 los_orig_loc[0] = Ds[0, ind_tmp]
                 los_orig_loc[1] = Ds[1, ind_tmp]
                 los_orig_loc[2] = Ds[2, ind_tmp]
@@ -306,23 +292,27 @@ def LOS_Calc_PInOut_VesStruct(double[:,::1] Ds,    double[:,::1] dus,
                                                               EpsPlane, False)
                         if found_new_kout :
                             kPOut_view[ind_tmp] = kpin_loc[0]
-                            VperpOut_view[0+3*ind_tmp] = struct_vperpin_view[0]
-                            VperpOut_view[1+3*ind_tmp] = struct_vperpin_view[1]
-                            VperpOut_view[2+3*ind_tmp] = struct_vperpin_view[2]
-                            IOut_view[2+3*ind_tmp] = indin_loc[0]
-                            IOut_view[0+3*ind_tmp] = 1+ii
-                            IOut_view[1+3*ind_tmp] = jj
+                            VperpOut_view[0,ind_tmp] = struct_vperpin_view[0]
+                            VperpOut_view[1,ind_tmp] = struct_vperpin_view[1]
+                            VperpOut_view[2,ind_tmp] = struct_vperpin_view[2]
+                            IOut_view[2,ind_tmp] = indin_loc[0]
+                            IOut_view[0,ind_tmp] = 1+ii
+                            IOut_view[1,ind_tmp] = jj
                             last_pout[0] = kPOut_view[ind_tmp] * los_dirv_loc[0] + los_orig_loc[0]
                             last_pout[1] = kPOut_view[ind_tmp] * los_dirv_loc[1] + los_orig_loc[1]
                             last_pout[2] = kPOut_view[ind_tmp] * los_dirv_loc[2] + los_orig_loc[2]
 
-            PyMem_Free(llen_lim)
-    PyMem_Free(lbounds)
-    PyMem_Free(langles)
-    return np.asarray(kPIn_view), np.asarray(kPOut_view),\
-      np.asarray(VperpOut_view),\
-      np.asarray(IOut_view)
-
+            free(llen_lim)
+    free(lbounds)
+    free(langles)
+    return np.asarray(kPIn_view), np.asarray(kPOut_view), VperpOut, IOut
+
+@cython.profile(True)
+@cython.linetrace(True)
+@cython.binding(True)
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                                 double [:,::1] VPoly, double [:,::1] vIn,
                                 int vin_shape,
@@ -366,6 +356,7 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
             # segment (i.e.: cone, not plane)
             # TODO : @LM : is this faster than checking abs(diff)>eps ?
             if (VPoly[1,jj+1] - VPoly[1,jj])**2 > EpsVz*EpsVz:
+                # TODO : @LM this probably can done matrix wise (qmatrix)
                 q = (Ds[2]-VPoly[1,jj]) / (VPoly[1,jj+1]-VPoly[1,jj])
                 # The intersection must stand on the segment
                 if q>=0 and q<1:
@@ -379,6 +370,8 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                         # (i.e.: k>=0)
                         # First solution
                         if -upscaDp - sqd >=0:
+                            # TODO : @LM - est-ce que c'est possible de le mat ?
+                            # ou le sortir d'ici
                             k = (-upscaDp - sqd)*invupar2
                             sol0, sol1 = Ds[0] + k*us[0], \
                                          Ds[1] + k*us[1]
@@ -546,15 +539,15 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                                     #print(10, k, q, A, B, C, sqd, v0, v1, jj)
 
     if not lim_is_none:
-        ephiIn0 = -sinl0
-        ephiIn1 =  cosl0
+        ephiIn0, ephiIn1 = -sinl0, cosl0
         if Cabs(us[0]*ephiIn0+us[1]*ephiIn1)>EpsPlane:
             k = -(Ds[0]*ephiIn0+Ds[1]*ephiIn1)/(us[0]*ephiIn0+us[1]*ephiIn1)
             if k>=0:
                 # Check if in VPoly
-                sol0 = (Ds[0] + k*us[0]) * cosl0 + (Ds[1] + k*us[1]) * sinl0
-                sol1 =  Ds[2] + k*us[2]
-                inter_bbox = is_point_in_path(vin_shape, VPoly[0,...], VPoly[1,...], sol0, sol1)
+                sol0, sol1 = (Ds[0]+k*us[0])*cosl0 + (Ds[1]+k*us[1])*sinl0, Ds[2]+k*us[2]
+                #if path_poly_t.contains_point([sol0,sol1], transform=None, radius=0.0):
+                #if ray_tracing(VPoly, sol0, sol1):
+                inter_bbox = pnpoly(vin_shape, VPoly[0,...], VPoly[1,...], sol0, sol1)
                 if inter_bbox:
                     # Check PIn (POut not possible for limited torus)
                     sca = us[0]*ephiIn0 + us[1]*ephiIn1
@@ -566,8 +559,7 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                         kin = k
                         indin = -1
 
-        ephiIn0 =  sinl1
-        ephiIn1 = -cosl1
+        ephiIn0, ephiIn1 = sinl1, -cosl1
         if Cabs(us[0]*ephiIn0+us[1]*ephiIn1)>EpsPlane:
             k = -(Ds[0]*ephiIn0+Ds[1]*ephiIn1)/(us[0]*ephiIn0+us[1]*ephiIn1)
             if k>=0:
@@ -575,7 +567,7 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                 # Check if in VPoly
                 #if path_poly_t.contains_point([sol0,sol1], transform=None, radius=0.0):
                 # if ray_tracing(VPoly, sol0, sol1):
-                inter_bbox = is_point_in_path(vin_shape, VPoly[0,...], VPoly[1,...], sol0, sol1)
+                inter_bbox = pnpoly(vin_shape, VPoly[0,...], VPoly[1,...], sol0, sol1)
                 if inter_bbox:
                     # Check PIn (POut not possible for limited torus)
                     sca = us[0]*ephiIn0 + us[1]*ephiIn1
@@ -632,13 +624,19 @@ cdef inline bint comp_inter_los_vpoly(double [3] Ds, double [3] us,
                 
     return res_kin != kpin_loc[0]
 
+# et creer vecteurs
+#    return np.asarray(kIn), np.asarray(kOut), np.asarray(vPerpOut), np.asarray(indOut)
+
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline void compute_inv_and_sign(const double[3] us,
                                       int[3] sign,
                                       double[3] inv_direction) nogil:
     cdef int t0 = 1000000
     # computing sign and direction
     for  ii in range(3):
-        if us[ii]*us[ii] < _VERYSMALL:
+        if us[ii]*us[ii] < _VERY_SMALL:
             inv_direction[ii] = t0
         else:
             inv_direction[ii] = 1./us[ii]
@@ -649,6 +647,9 @@ cdef inline void compute_inv_and_sign(const double[3] us,
 
     return
 
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline bint ray_intersects_abba_bbox(const int[3] sign,
                                           const double[3] inv_direction,
                                           const double[6] bounds,
@@ -690,7 +691,11 @@ cdef inline bint ray_intersects_abba_bbox(const int[3] sign,
     return  res
 
 
-cdef inline bint is_point_in_path(int nvert, double[:] vertx, double[:] verty, double testx, double testy) nogil:
+
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cdef inline bint pnpoly(int nvert, double[:] vertx, double[:] verty, double testx, double testy) nogil:
     cdef int i
     cdef bint c = 0
     for i in range(nvert):
@@ -699,17 +704,19 @@ cdef inline bint is_point_in_path(int nvert, double[:] vertx, double[:] verty, d
             c = not c
     return c
 
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline void Calc_LOS_PInOut_Tor(double [:,::1] Ds, double [:,::1] us,
-                                     double [:,::1] VPoly, double [:,::1] vIn,
-                                     double[:] kPIn_view, double[:] kPOut_view,
-                                     double[:] VperpOut_view, long[:] IOut_view,
-                                     int Nl,
-                                     double Rmin, bint lim_is_none, double L0, double L1,
-                                     bint Forbid,  double EpsUz,
-                                     double EpsVz, double EpsA,
-                                     double EpsB,  double EpsPlane):
-
-    cdef int ii, jj, Ns=vIn.shape[1]
+                         double [:,::1] VPoly, double [:,::1] vIn,
+                         double[:] kPIn_view, double[:] kPOut_view,
+                         double[:,::1] VperpOut_view, long[:,::1] IOut_view,
+                         double Rmin, bint lim_is_none, double L0, double L1,
+                         bint Forbid, double EpsUz,
+                         double EpsVz, double EpsA,
+                         double EpsB, double EpsPlane):
+
+    cdef int ii, jj, Nl=Ds.shape[1], Ns=vIn.shape[1]
     cdef double upscaDp, upar2, Dpar2, Crit2, kout, kin, invDpar2
     cdef int indout=0, Done=0
     cdef double L=0., S1X=0., S1Y=0., S2X=0., S2Y=0., sca=0., sca0=0., sca1=0., sca2=0.
@@ -738,9 +745,9 @@ cdef inline void Calc_LOS_PInOut_Tor(double [:,::1] Ds, double [:,::1] us,
         loc_ds[0] = Ds[0,ii]
         loc_ds[1] = Ds[1,ii]
         loc_ds[2] = Ds[2,ii]
-        loc_vp[0] = VperpOut_view[0+3*ii]
-        loc_vp[1] = VperpOut_view[1+3*ii]
-        loc_vp[2] = VperpOut_view[2+3*ii]
+        loc_vp[0] = VperpOut_view[0,ii]
+        loc_vp[1] = VperpOut_view[1,ii]
+        loc_vp[2] = VperpOut_view[2,ii]
         upscaDp = loc_us[0]*loc_ds[0] + loc_us[1]*loc_ds[1]
         upar2 = loc_us[0]*loc_us[0] + loc_us[1]*loc_us[1]
         Dpar2 = loc_ds[0]*loc_ds[0] + loc_ds[1]*loc_ds[1]
@@ -764,38 +771,65 @@ cdef inline void Calc_LOS_PInOut_Tor(double [:,::1] Ds, double [:,::1] us,
         Crit2 = upar2*Crit2_base
         kpin_loc[0]  = kPIn_view[ii]
         kpout_loc[0] = kPOut_view[ii]
-        indout_loc[0] = IOut_view[2 + 3*ii]
+        indout_loc[0] = IOut_view[2, ii]
         found_new = comp_inter_los_vpoly(loc_ds, loc_us, VPoly, vIn, Ns, lim_is_none,
                                          L0, L1, kpin_loc, kpout_loc, indout_loc, loc_vp,
                                          Forbidbis, upscaDp, upar2, Dpar2, invDpar2,
                                          S1X, S1Y, S2X, S2Y, Crit2, EpsUz, EpsVz, EpsA, EpsB,
                                          EpsPlane, True)
         if found_new:
-            kPIn_view[ii]         = kpin_loc[0]
-            kPOut_view[ii]        = kpout_loc[0]
-            IOut_view[2+3*ii]     = indout_loc[0]
-            IOut_view[0+3*ii]     = 0
-            IOut_view[1+3*ii]     = 0
-            VperpOut_view[0+3*ii] = loc_vp[0]
-            VperpOut_view[1+3*ii] = loc_vp[1]
-            VperpOut_view[2+3*ii] = loc_vp[2]
+            kPIn_view[ii]       = kpin_loc[0]
+            kPOut_view[ii]      = kpout_loc[0]
+            IOut_view[2, ii]    = indout_loc[0]
+            IOut_view[0, ii]    = 0
+            IOut_view[1, ii]    = 0
+            VperpOut_view[0,ii] = loc_vp[0]
+            VperpOut_view[1,ii] = loc_vp[1]
+            VperpOut_view[2,ii] = loc_vp[2]
 
         else:
-            kPIn_view[ii]         = Cnan
-            kPOut_view[ii]        = Cnan
-            IOut_view[2+3*ii]     = -1000000
-            IOut_view[0+3*ii]     = 0
-            IOut_view[1+3*ii]     = 0
-            VperpOut_view[0+3*ii] = Cnan
-            VperpOut_view[1+3*ii] = Cnan
-            VperpOut_view[2+3*ii] = Cnan
+            kPIn_view[ii]       = Cnan
+            kPOut_view[ii]      = Cnan
+            IOut_view[2, ii]    = -1000000
+            IOut_view[0, ii]    = 0
+            IOut_view[1, ii]    = 0
+            VperpOut_view[0,ii] = Cnan
+            VperpOut_view[1,ii] = Cnan
+            VperpOut_view[2,ii] = Cnan
+            
 
     return
 
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cdef inline void compute_bbox(int nvert, double[:] vertr, double[:] vertz,
+       double[6] bounds):
+    cdef int ii
+    cdef double rmax=vertr[0], zmin=vertz[0], zmax=vertz[0]
+    cdef double tmp_val
+    for ii in range(1, nvert):
+        tmp_val = vertr[ii]
+        if tmp_val > rmax:
+            rmax = tmp_val
+        tmp_val = vertz[ii]
+        if tmp_val > zmax:
+            zmax = tmp_val
+        elif tmp_val < zmin:
+            zmin = tmp_val
+    bounds[0] = -rmax
+    bounds[1] = -rmax
+    bounds[2] = zmin
+    bounds[3] = rmax
+    bounds[4] = rmax
+    bounds[5] = zmax
+    return
 
-
-cdef inline void compute_bbox_extr(int nvert, double[:,::1] vert,
-                                   double[6] bounds) nogil:
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cdef inline void compute_bbox2(int nvert, double[:,::1] vert,
+       double[6] bounds) nogil:
     cdef int ii
     cdef double rmax=vert[0,0], zmin=vert[1,0], zmax=vert[1,0]
     cdef double tmp_val
@@ -816,7 +850,9 @@ cdef inline void compute_bbox_extr(int nvert, double[:,::1] vert,
     bounds[5] = zmax
     return
 
-
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline void compute_bbox_lim(int nvert, double[:,::1] vert,
                                   double[6] bounds, double lmin, double lmax) nogil:
     cdef int ii
@@ -873,7 +909,53 @@ cdef inline void compute_bbox_lim(int nvert, double[:,::1] vert,
     return
 
 
+cdef inline void coordshift_simple(double[:,::1] pts, bool in_is_cartesian=True,
+                       double CrossRef=0., double cos_phi=0., double sin_phi=0.):
 
+    cdef int npts = pts.shape[1]
+    cdef int ii
+    cdef double x, y, z
+    cdef double r, p
+    if in_is_cartesian:
+        if CrossRef==0.:
+            for ii in range(npts):
+                x = pts[0, ii]
+                y = pts[1, ii]
+                z = pts[2, ii]
+                pts[0, ii] = Csqrt(x*x+y*y)
+                pts[1, ii] = z
+                pts[2, ii] = Catan2(y,x)
+        else:
+            for ii in range(npts):
+                x = pts[0, ii]
+                y = pts[1, ii]
+                z = pts[2, ii]
+                pts[0, ii] = Csqrt(x*x+y*y)
+                pts[1, ii] = z
+                pts[2, ii] = CrossRef
+
+    else:
+        if CrossRef==0.:
+            for ii in range(npts):
+                r = pts[0, ii]
+                z = pts[1, ii]
+                p = pts[2, ii]
+                pts[0, ii] = r*Ccos(p)
+                pts[1, ii] = r*Csin(p)
+                pts[2, ii] = z
+        else:
+            for ii in range(npts):
+                r = pts[0, ii]
+                z = pts[1, ii]
+                pts[0, ii] = r*cos_phi
+                pts[1, ii] = r*sin_phi
+                pts[2, ii] = z
+    return
+
+
+@cython.cdivision(True)
+@cython.wraparound(False)
+@cython.boundscheck(False)
 cdef inline void coordshift_simple1d(double[3] pts, bint in_is_cartesian=True,
                                      double CrossRef=0., double cos_phi=0.,
                                      double sin_phi=0.) nogil:
@@ -911,4 +993,3 @@ cdef inline void coordshift_simple1d(double[3] pts, bint in_is_cartesian=True,
             pts[2] = z
     return
 
-
diff --git a/tofu/geom/_core.py b/tofu/geom/_core.py
index 3bb2e0a..990b189 100644
--- a/tofu/geom/_core.py
+++ b/tofu/geom/_core.py
@@ -2430,7 +2430,7 @@ class Rays(utils.ToFuObject):
             dkwd = dict(Lim=Lim, nLim=nLim, ntotStruct=num_tot_structs,
                         LSPoly=lSPoly, LSLim=lSLim,
                         lSnLim=lSnLim, LSVIn=lSVIn, VType=VType,
-                        RMin=-1, Forbid=True, EpsUz=1.e-6, EpsVz=1.e-9,
+                        RMin=None, Forbid=True, EpsUz=1.e-6, EpsVz=1.e-9,
                         EpsA=1.e-9, EpsB=1.e-9, EpsPlane=1.e-9, Test=True)
         else:
             # --------------------------------
diff --git a/tofu/tests/tests01_geom/test00_Laura/test_LOS_west_geom.py b/tofu/tests/tests01_geom/test00_Laura/test_LOS_west_geom.py
index b126db7..2893e1a 100644
--- a/tofu/tests/tests01_geom/test00_Laura/test_LOS_west_geom.py
+++ b/tofu/tests/tests01_geom/test00_Laura/test_LOS_west_geom.py
@@ -48,6 +48,7 @@ def prepare_inputs(vcam, config, method='ref'):
             num_tot_structs += len(ss.Lim)
 
     largs = [D, u, VPoly, VVIn]
+    print("Lim = ", Lim)
     dkwd = dict(Lim=Lim, nLim=nLim, ntotStruct=num_tot_structs,
                 LSPoly=lSPoly, LSLim=lSLim,
                 lSnLim=lSnLim, LSVIn=lSVIn, VType=VType,
