

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ToFu_Mesh &mdash; ToFu alpha documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     'alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="ToFu alpha documentation" href="index.html" />
    <link rel="next" title="ToFu_MatComp" href="ToFu_MatComp.html" />
    <link rel="prev" title="ToFu_Geom" href="ToFu_Geom.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ToFu_MatComp.html" title="ToFu_MatComp"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ToFu_Geom.html" title="ToFu_Geom"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">ToFu alpha documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tofu-mesh">
<h1><strong>ToFu_Mesh</strong><a class="headerlink" href="#tofu-mesh" title="Permalink to this headline">¶</a></h1>
<p>(This project is not finalised yet, work in progress...)</p>
<p><strong>ToFu_Mesh</strong>, is a ToFu module aimed at handling spatial discretisation of a 3D scalar field in a vacuum chamber (typically the isotropic emissivity of a plasma). Such discretisation is done using B-splines of any order relying on a user-defined rectangular mesh (possibily with variable grid size). It is particularly useful for tomographic inversions and fast synthetic diagnostics.</p>
<p>It is designed to be used jointly with the other <strong>ToFu</strong> modules, in particular with <strong>ToFu_Geom</strong> and <strong>ToFu_MatComp</strong>. It is a ToFu-specific discretisation library which remains quite simple and straightforward. However, its capacities are limited to rectangular mesh and it may ultimately be percieved as a much less powerful version of <strong>PIGASUS/CAID</strong>. Users who wish to use <strong>ToFu</strong> only for tomographic inversions may find <strong>ToFu_Mesh</strong> sufficient for thir needs, others, who wish to use a synthetic diagnostic approach, and/or to use <strong>ToFu_Mesh</strong> jointly with plasma physics codes (MHD...) may prefer using <strong>PIGASUSCAID</strong> for spatial discreatisation.</p>
<p>Hence, <strong>ToFu_Mesh</strong> mainly provides two object classes : one representing the mesh, and the other one (which uses the latter) representing the basis functions used for discretisation:</p>
<table border="1" class="docutils">
<caption>The object classes in <strong>ToFu_Geom</strong></caption>
<colgroup>
<col width="17%" />
<col width="50%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
<th class="head">Inputs needed</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ID</td>
<td>An identity object that is used by all <strong>ToFu</strong> objects to store specific identity information (name, file name if the object is to be saved, names of other objects necessary for the object creation, date of creation, signal name, signal group, version...)</td>
<td>By default only a name (a character string) is necessary, A default file name is constructed (including the object class and date of creation), but every attribute can be modified and extra attribute can be added to suit the specific need of the the data acquisition system of each fusion experiment or the naming conventions of each laboratory.</td>
</tr>
<tr class="row-odd"><td>Mesh1D, Mesh2D, Mesh3D</td>
<td>1D, 2D and 3D mesh objects, storing the knots and centers, as well as the correspondence between knots and centers in both ways. The higher dimension mesh objects are defined using lower dimension mesh objects. The Mesh 2D object includes an enveloppe polygon. They all include plotting methods and methods to select a subset of the total mesh. The Mesh 3D object is not finished.</td>
<td>A numpy array of knots, which can be defined using some of the functions detailed below (for easy creation of linearly spaced knots with chosen resolution).</td>
</tr>
<tr class="row-even"><td>BaseFun1D, BaseFunc2D, BaseFunc3D</td>
<td>1D, 2D and 3D families of B-splines, relying on Mesh1D, Mesh2D, Mesh3D objects, with chosen degree and multiplicity for each dimension. Includes methods for plotting, for determining the support and knots and centers associated to each basis function, as well as for computing 1st, 2nd or 3rd order derivatives (as functions), and local value (summation of all basis functions or their derivatives at a given point and for given weights). Includes methods for computing integrals of derivative operators...</td>
<td>A Mesh object of the adapted dimension, and a degree value.</td>
</tr>
</tbody>
</table>
<p>The following will give a more detailed description of each object and its attributes and methods through a tutorial at the end of which you should be able to create your own mesh and basis functions and access its main characteristics.</p>
<div class="section" id="getting-started-with-tofu-mesh">
<h2>Getting started with ToFu_Mesh<a class="headerlink" href="#getting-started-with-tofu-mesh" title="Permalink to this headline">¶</a></h2>
<p>Once you have downloaded the whole <strong>ToFu</strong> package (and made sur you also have scipy, numpy and matplotlib, as well as a free polygon-handling library called Polygon which can be downloaded at ), just start a python interpreter and import <strong>ToFu_Geom</strong> and <strong>ToFu_Mesh</strong> (we will always import <strong>ToFu</strong> modules &#8216;as&#8217; a short name to keep track of the functionalities of each module). To handle the local path of your computer, we will also import the small module called <strong>ToFu_PathFile</strong>, and <strong>matplotlib</strong> and <strong>numpy</strong> will also be useful:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">ToFu_Geom</span> <span class="kn">as</span> <span class="nn">TFG</span>
<span class="kn">import</span> <span class="nn">ToFu_Mesh</span> <span class="kn">as</span> <span class="nn">TFM</span>
<span class="kn">import</span> <span class="nn">ToFu_PathFile</span> <span class="kn">as</span> <span class="nn">TFPF</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pck</span> <span class="c"># for saving objects</span>
<span class="kn">import</span> <span class="nn">ToFu_Defaults</span> <span class="kn">as</span> <span class="nn">TFD</span>
</pre></div>
</div>
<p>The os module is used for exploring directories and the cPickle module for saving and loading objects.</p>
</div>
<div class="section" id="the-mesh1d-mesh2d-and-mesh3d-object-classes">
<h2>The Mesh1D, Mesh2D and Mesh3D object classes<a class="headerlink" href="#the-mesh1d-mesh2d-and-mesh3d-object-classes" title="Permalink to this headline">¶</a></h2>
<p>In this section, we describe the Mesh objects starting from the unidimensional to the 3D version.</p>
<table border="1" class="docutils">
<caption>The attributes of a Mesh1D object</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>self.ID</td>
<td>The ID class of the object</td>
</tr>
<tr class="row-odd"><td>self.NCents, self.NKnots</td>
<td>The number of mesh elements or centers (resp. knots) of the object (typically self.NKnots = self.NCents+1)</td>
</tr>
<tr class="row-even"><td>self.Cents, self.Knots</td>
<td>The coordinates of the centers and knots themselves, as two numpy arrays</td>
</tr>
<tr class="row-odd"><td>self.Lengths, self.Length, self.BaryL, self.BaryP</td>
<td>The length of each mesh element, the total length of the mesh and the center of mass of the mesh (i.e.: weight by the respective length of each mesh element), and the barycenter of the self.Cents</td>
</tr>
<tr class="row-even"><td>self.Cents_Knotsind, self.Knots_Centsind</td>
<td>The index arrays used to get the correspondence between each mesh element (resp, each knot) and its associated knots (resp. its associated mesh elements)</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption>The attributes of a Mesh2D object</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>self.ID</td>
<td>The ID class of the object</td>
</tr>
<tr class="row-odd"><td>self.MeshR, self.MeshZ</td>
<td>The two Mesh1D objects used to create this Mesh2D object</td>
</tr>
<tr class="row-even"><td>self.NCents, self.NKnots</td>
<td>The number of mesh elements or centers (resp. knots) of the object (typically self.NKnots = self.NCents+1)</td>
</tr>
<tr class="row-odd"><td>self.Cents, self.Knots</td>
<td>The coordinates of the centers and knots themselves, as two numpy arrays</td>
</tr>
<tr class="row-even"><td>self.Surfs, self.Surf, self.VolAngs, self.VolAng, self.BaryV, self.BaryS, self.BaryL, self.BaryP</td>
<td>The surface of each mesh element, the total surface of the mesh, the volume per unit angle of each mesh element, the total volume per unit angle, the volume barycenter of the mesh (i.e. taking into account not only the surface repartition but also the toroidal geometry), the center of mass of the mesh (i.e.: weight by the respective surface of each mesh element), the middle point (the average between the extreme (R,Z) coordinates) and the barycenter of all the self.Cents</td>
</tr>
<tr class="row-odd"><td>self.Cents_Knotsind, self.Knots_Centsind</td>
<td>The index arrays used to get the correspondence between each mesh element (resp, each knot) and its associated knots (resp. its associated mesh elements)</td>
</tr>
<tr class="row-even"><td>self.BoundPoly</td>
<td>The boundary polygon of the mesh, useful for fast estimation whether a point lies inside the mesh support or not.</td>
</tr>
</tbody>
</table>
<p>In an experiment-oriented perspective, <strong>ToFu_Mesh</strong> comes with simple functions to help you quickly define an optimal 1D grid, with explicit parametrisation of the spatial resolution on regions of interest.
For example, if you want to define a 1D grid with a 5 cm resolution near the first end, that gradually refines to 1 cm at a given point, stays 1 cm for a given length and is then gradually enlarged to 6 cm at the other end, you just have to feed in the points of interest and their associated resolution to the <em>LinMesh_List</em> function, as a two lists of corresponding (start,end) tuples.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#Knots, Res = TFM.LinMesh_List([(1.,1.5),(1.5,1.8),(1.8,2.)], [(0.06,0.02),(0.02,0.02),(0.02,0.08)])#TFM.LinMesh_List([(0.,10.)], [(1.,1.)])</span>
<span class="c">#print Res</span>
<span class="c">#print Knots</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># [(0.0569230769230769, 0.02), (0.02, 0.02), (0.02, 0.07999999999999999)]</span>
<span class="c"># [ 1.          1.05692308  1.11076923  1.16153846  1.20923077  1.25384615  1.29538462  1.33384615  1.36923077  1.40153846  1.43076923  1.45692308     1.48        1.5         1.52        1.54        1.56        1.58        1.6  1.62        1.64        1.66        1.68        1.7         1.72        1.74     1.76        1.78        1.8         1.82        1.86        1.92        2.        ]</span>
</pre></div>
</div>
<p>You can then feed the resulting knots numpy array to the Mesh1D object class and use this object methods to access all the features of interest of the created mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">M1</span> <span class="o">=</span> <span class="n">TFM</span><span class="o">.</span><span class="n">Mesh1D</span><span class="p">(</span><span class="s">&#39;M1&#39;</span><span class="p">,</span> <span class="n">Knots</span><span class="p">)</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">M1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Elt</span><span class="o">=</span><span class="s">&#39;KCN&#39;</span><span class="p">)</span>
<span class="n">ax2</span> <span class="o">=</span> <span class="n">M1</span><span class="o">.</span><span class="n">plot_Res</span><span class="p">()</span>
<span class="c">#plt.show()</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_M1.png"><img alt="Arbitrary 1D mesh with customized resolution in chosen regions" src="_images/Fig_Tutor_ToFuMesh_M1.png" style="width: 500.0px; height: 200.0px;" /></a>
<p class="caption">Arbitrary 1D mesh with customized resolution in chosen regions</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_M1_Res.png"><img alt="Local spatial resolution of the created 1D mesh" src="_images/Fig_Tutor_ToFuMesh_M1_Res.png" style="width: 500.0px; height: 250.0px;" /></a>
<p class="caption">Local spatial resolution of the created 1D mesh</p>
</div>
<p>It can seen that the algorithm tried to render a mesh with the required resolution, even though it had to decrease it slightly around the first point, where it is lower than the required 6 cm (this is necessary due to the necessity to the number of mesh elements which must be an integer, thus leading to rounding). This is shown also in the <em>Res</em> variable which returns the actual resolution.
Like for the <strong>ToFu_Geom</strong> plotting routines, the &#8216;Elt&#8217; keyword argument provides you with the possibility of choosing what is going to be plotted (the knots &#8216;K&#8217;, the centers &#8216;C&#8217; and/or the numbers &#8216;N&#8217;).</p>
<p>The Mesh2D object class relies on the same basics, except that its multi-dimensional nature means that it has extra methods for easy handling of mesh elements. Let us for example create a coarse 2D mesh using 2 different 1D mesh objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">PolyRef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">RP</span> <span class="o">+</span> <span class="s">&#39;/Inputs/AUG_Tor.txt&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float&#39;</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s">&#39;#&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">converters</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">AUG</span> <span class="o">=</span> <span class="n">TFG</span><span class="o">.</span><span class="n">Tor</span><span class="p">(</span><span class="s">&#39;AUG&#39;</span><span class="p">,</span><span class="n">PolyRef</span><span class="p">)</span>
<span class="n">KnotsR</span><span class="p">,</span> <span class="n">ResR</span> <span class="o">=</span> <span class="n">TFM</span><span class="o">.</span><span class="n">LinMesh_List</span><span class="p">([(</span><span class="n">AUG</span><span class="o">.</span><span class="n">PRMin</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">1.5</span><span class="p">),(</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.75</span><span class="p">),(</span><span class="mf">1.75</span><span class="p">,</span><span class="n">AUG</span><span class="o">.</span><span class="n">PRMax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])],</span> <span class="p">[(</span><span class="mf">0.06</span><span class="p">,</span><span class="mf">0.02</span><span class="p">),(</span><span class="mf">0.02</span><span class="p">,</span><span class="mf">0.02</span><span class="p">),(</span><span class="mf">0.02</span><span class="p">,</span><span class="mf">0.06</span><span class="p">)])</span>
<span class="n">KnotsZ</span><span class="p">,</span> <span class="n">ResZ</span> <span class="o">=</span> <span class="n">TFM</span><span class="o">.</span><span class="n">LinMesh_List</span><span class="p">([(</span><span class="n">AUG</span><span class="o">.</span><span class="n">PZMin</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mf">0.1</span><span class="p">),(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),(</span><span class="mf">0.1</span><span class="p">,</span><span class="n">AUG</span><span class="o">.</span><span class="n">PZMax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])],</span> <span class="p">[(</span><span class="mf">0.10</span><span class="p">,</span><span class="mf">0.02</span><span class="p">),(</span><span class="mf">0.02</span><span class="p">,</span><span class="mf">0.02</span><span class="p">),(</span><span class="mf">0.02</span><span class="p">,</span><span class="mf">0.08</span><span class="p">)])</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">TFM</span><span class="o">.</span><span class="n">Mesh2D</span><span class="p">(</span><span class="s">&#39;M2&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">KnotsR</span><span class="p">,</span><span class="n">KnotsZ</span><span class="p">])</span>
<span class="c">#ax = M2.plot(Elt=&#39;MBKC&#39;)</span>
<span class="c">#plt.show()</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_M2_Raw.png"><img alt="Arbitrary 2D mesh with customized resolution in chosen regions" src="_images/Fig_Tutor_ToFuMesh_M2_Raw.png" style="width: 400.0px; height: 400.0px;" /></a>
<p class="caption">Arbitrary 2D mesh with customized resolution in chosen regions</p>
</div>
<p>The Mesh2D class comes with a method to automatically create another Mesh2D object that can be seen as a sub-mesh (only the elements lying inside an input polygon are kept, the rest being memorized only as &#8216;Background&#8217;). In our example, we can use a specific method of the TFG.Tor object class to create a smooth convex polygon lying inside the Tor enveloppe (see the kwdargs for customization of the smoothing and offset) to concentrate on the region where most SXR radiation comes from:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Poly</span> <span class="o">=</span> <span class="n">AUG</span><span class="o">.</span><span class="n">get_InsideConvexPoly</span><span class="p">(</span><span class="n">Spline</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">M2bis</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">get_SubMeshPolygon</span><span class="p">(</span><span class="n">Poly</span><span class="p">,</span> <span class="n">NLim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c">#ax = AUG.plot_PolProj(Elt=&#39;P&#39;)</span>
<span class="c">#ax = M2bis.plot(Elt=&#39;BM&#39;, ax=ax)</span>
<span class="c">#ax1, ax2, ax3, axcb = M2bis.plot_Res()</span>
<span class="c">#plt.show()</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_M2.png"><img alt="Submesh of the 2D mesh with customized resolution in chosen regions with selected elements only (using an input polygon)" src="_images/Fig_Tutor_ToFuMesh_M2.png" style="width: 400.0px; height: 500.0px;" /></a>
<p class="caption">Submesh of the 2D mesh with customized resolution in chosen regions with selected elements only (using an input polygon)</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_M2_Res.png"><img alt="Local spatial resolution of the created 2D mesh (both linear and surface)" src="_images/Fig_Tutor_ToFuMesh_M2_Res.png" style="width: 500.0px; height: 500.0px;" /></a>
<p class="caption">Local spatial resolution of the created 2D mesh (both linear and surface)</p>
</div>
<p>Here, the &#8216;NLim&#8217; kwdarg is used to specifiy how many corners of a mesh element must lie inside the input polygon so that this mesh element can be counted in.</p>
<p>Now, the Mesh2D object class provides tools to easily select and plot chosen elements of the 2D mesh. For example, if you want to get the coordinates of the four knots associated to the mesh element number 50, you can use the attribute &#8216;Centers_Knotsind&#8217; to get them, and then plot them:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Knots50</span> <span class="o">=</span> <span class="n">M2bis</span><span class="o">.</span><span class="n">Knots</span><span class="p">[:,</span><span class="n">M2bis</span><span class="o">.</span><span class="n">Cents_Knotsind</span><span class="p">[:,</span><span class="mi">50</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
<span class="k">print</span> <span class="n">Knots50</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">M2bis</span><span class="o">.</span><span class="n">plot_Cents</span><span class="p">(</span><span class="n">Ind</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">Elt</span><span class="o">=</span><span class="s">&#39;BMKC&#39;</span><span class="p">)</span>
<span class="c">#plt.show()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># [[ 1.69230769  1.71153846  1.71153846  1.69230769]</span>
<span class="c">#  [-0.94421053 -0.94421053 -0.85868421 -0.85868421]]</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_M2_Cents.png"><img alt="Selected mesh element and its associated knots" src="_images/Fig_Tutor_ToFuMesh_M2_Cents.png" style="width: 400.0px; height: 400.0px;" /></a>
<p class="caption">Selected mesh element and its associated Knots</p>
</div>
<p>Similarly, you can get and plot all the mesh element centers associated to knots number 160, 655 and 1000:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">160</span><span class="p">,</span><span class="mi">655</span><span class="p">,</span><span class="mi">1000</span><span class="p">])</span>
<span class="n">Cents</span> <span class="o">=</span> <span class="n">M2bis</span><span class="o">.</span><span class="n">Cents</span><span class="p">[:,</span><span class="n">M2bis</span><span class="o">.</span><span class="n">Knots_Centsind</span><span class="p">[:,</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
<span class="k">print</span> <span class="n">Cents</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">M2bis</span><span class="o">.</span><span class="n">plot_Knots</span><span class="p">(</span><span class="n">Ind</span><span class="o">=</span><span class="n">ind</span><span class="p">,</span> <span class="n">Elt</span><span class="o">=</span><span class="s">&#39;BMKC&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># [[ 1.83922727  1.07454545  1.70192308  1.87418182  1.13548182  1.72115385   1.83922727  1.07454545  1.70192308  1.87418182  1.13548182  1.72115385]</span>
<span class="c">#  [-0.66452632 -0.05        0.13140693 -0.66452632 -0.05        0.13140693  -0.59428947 -0.03        0.15562771 -0.59428947 -0.03        0.15562771]]</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_M2_Knots.png"><img alt="Selected mesh knots and their associated mesh elements" src="_images/Fig_Tutor_ToFuMesh_M2_Knots.png" style="width: 400.0px; height: 400.0px;" /></a>
<p class="caption">Selected mesh knots and their associated mesh elements</p>
</div>
<p>The Mesh3D object class is currently being built... to be finished.</p>
<p>Now that we have access to a mesh, we can build basis functions on it. The basis functions available in <strong>ToFu_Mesh</strong> are all B-splines, as illustrated below.</p>
</div>
<div class="section" id="the-basefunc1d-basefunc2d-and-basefunc3d-object-classes">
<h2>The BaseFunc1D, BaseFunc2D and BaseFunc3D object classes<a class="headerlink" href="#the-basefunc1d-basefunc2d-and-basefunc3d-object-classes" title="Permalink to this headline">¶</a></h2>
<p>The use of B-spline allows for more flexibility and more accuracy than the standard pixels (which are B-splines of degree 0). Indeed, most of the tomographic algorithms using series expansion in physical space assess the regularity of the solution by computing the integral of a norm of one of its derivatives. While the use of pixels forces you to use discrete approximations of the derivative operators, the use of B-splines of sufficient degree allows to use an exact formulation of the derivative operators.</p>
<p>The attributes of a BaseFunc1D objects are the following:</p>
<table border="1" class="docutils">
<caption>The attributes of a BaseFunc1D object</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>self.ID</td>
<td>The ID class of the object</td>
</tr>
<tr class="row-odd"><td>self.Mesh</td>
<td>The Mesh1D object on which the basis functions are built</td>
</tr>
<tr class="row-even"><td>self.LFunc, self.NFunc, self.Deg, self.Bound</td>
<td>The list of basis functions and the number of basis functions (self.NFunc=len(self.LFunc)), the degree of the basis functions, and the boundary condition (only 0 implemented so far, all points have 1 multiplicity)</td>
</tr>
<tr class="row-odd"><td>self.Func_Centsind, self.Func_Knotsind, self.Func_PMax</td>
<td>An array giving the correspondence index between each basis function and all its associated mesh centers (and there are methods to go the other way around), its associated mesh knots, and the position of the maximum of each basis function (either oa mesh center or a knot depending on its degree).</td>
</tr>
</tbody>
</table>
<p>Other quantities, indices or functions of interest are not stored as attributes, but instead accessible through methods, as will be illustrated in the following:</p>
<p>One of the most common issues in SXR tomography on Tokamaks is the boundary constraint that one must enforce at the plasma edge to force the SXR emissivity field to smoothlty decrease to zero in order to avoid artefacts on the tomographic reconstructions. With pixels, this usually has to be done by adding artificial detectors that &#8216;see&#8217; the edge pixels only and are associated to a &#8216;measured&#8217; value of zero (and the regularisation process does the rest). With B-splines of degree 2 for example, this constraint can be built-in the basis functions and enforced without having to add any artificial constraint, provided the underlying mesh is created accordingly, as illustrated in the following example, where BaseFunc1D object of degree 2 is created and a method is used to fit its coefficients to an input gaussian-like function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">BF1</span> <span class="o">=</span> <span class="n">TFM</span><span class="o">.</span><span class="n">BaseFunc1D</span><span class="p">(</span><span class="s">&#39;BF1&#39;</span><span class="p">,</span><span class="n">M1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">FF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">xx</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">0.2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">xx</span><span class="o">-</span><span class="mf">1.65</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">0.01</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Coefs</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">BF1</span><span class="o">.</span><span class="n">get_Coefs</span><span class="p">(</span><span class="n">ff</span><span class="o">=</span><span class="n">FF</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">BF1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Coefs</span><span class="o">=</span><span class="n">Coefs</span><span class="p">,</span> <span class="n">Elt</span><span class="o">=</span><span class="s">&#39;TL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mi">500</span><span class="p">),</span> <span class="n">FF</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mi">500</span><span class="p">)),</span> <span class="n">c</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Ref function&#39;</span><span class="p">)</span>
<span class="c">#ax.figure.savefig(RP+&quot;/../doc/source/figures_doc/Fig_Tutor_ToFuMesh_BF1.png&quot;,frameon=None,bbox_inches=0)  # Saving for Tutorial illustration</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_BF1.png"><img alt="1D B-splines of a BaseFunc1D object, with arbitrary coefficients to create a gaussian-like profile" src="_images/Fig_Tutor_ToFuMesh_BF1.png" style="width: 500.0px; height: 300.0px;" /></a>
<p class="caption">1D B-splines of a BaseFunc1D object, with arbitrary coefficients to create a gaussian-like profile</p>
</div>
<p>By construction, and because we have only used points with multiplicity equal to one so far, the profile can only decrease smoothly to zero near the edge.</p>
<p>The BaseFunc1D object also comes with methods to compute and plot local values its derivatives, or of some operators of interest that rely on derivatives. In particular, the following example shows the plots of the first derivative, the second derivative and a quantity called the Fisher Information that is the first derivative squared and divided by the function value. As usual, the &#8216;Elt&#8217; kwdarg is used to specify whether we want only the total function (&#8216;T&#8217;) or the detail of the list of all the underlying B-splines (&#8216;L&#8217;, which is not possible for non-linear operators):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ax</span> <span class="o">=</span> <span class="n">BF1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Coefs</span><span class="o">=</span><span class="n">Coefs</span><span class="p">,</span> <span class="n">Deriv</span><span class="o">=</span><span class="s">&#39;D2&#39;</span><span class="p">,</span> <span class="n">Elt</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span><span class="n">Totdict</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;c&#39;</span><span class="p">:</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="s">&#39;lw&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">BF1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">Coefs</span><span class="o">=</span><span class="n">Coefs</span><span class="p">,</span> <span class="n">Deriv</span><span class="o">=</span><span class="s">&#39;D1N2&#39;</span><span class="p">,</span> <span class="n">Elt</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span><span class="n">Totdict</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;c&#39;</span><span class="p">:</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;lw&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">RP</span><span class="o">+</span><span class="s">&quot;/../doc/source/figures_doc/Fig_Tutor_ToFuMesh_BF1_Deriv.png&quot;</span><span class="p">,</span><span class="n">frameon</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># Saving for Tutorial illustration</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_BF1_Deriv.png"><img alt="Some quantities of interest, based on derivative operators, for the chosen BaseFunc1D object" src="_images/Fig_Tutor_ToFuMesh_BF1_Deriv.png" style="width: 500.0px; height: 300.0px;" /></a>
<p class="caption">Some quantities of interest, based on derivative operators, for the chosen BaseFunc1D object</p>
</div>
<p>This was done using the &#8216;Deriv&#8217; kwdarg, which can take several values, as shown in the table below:</p>
<table border="1" class="docutils">
<caption>The available values of the &#8216;Deriv&#8217; keyword argument for a BaseFunc1D object</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0, 1, 2, 3 or &#8216;D0&#8217;, &#8216;D1&#8217;, &#8216;D2&#8217;, &#8216;D3&#8217;</td>
<td>Respectively the B-splines themselves (0-th order derivative), the first, second and third order derivative</td>
</tr>
<tr class="row-odd"><td>&#8216;D0N2&#8217;, &#8216;D1N2&#8217;, &#8216;D2N2&#8217;, &#8216;D3N2&#8217;</td>
<td>The squared norm of the 0th, 1st, 2nd and 3rd order derivatives</td>
</tr>
<tr class="row-even"><td>&#8216;D1FI&#8217;</td>
<td>The Fisher Information, which is the squared norm of the 1st order derivative, divided by the function value</td>
</tr>
</tbody>
</table>
<p>Keep in mind that we are only using exact derivatives here, so the current version of <strong>ToFu_Mesh</strong> does not provide discretised operators and you have to make sure that you only compute derivatives for B-splines of sufficiently high degree.</p>
<p>Finally, the BaseFunc1D object also comes with methods to compute the value of the integral of the previous operators on the support of the B-spline. When it is possible, another method also returns the matrix that can be used to compute this integral using a vector of coefficients for the B-splines, along with a flag &#8216;m&#8217; that indicates how the matrix should be used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Getting integral operators and values</span>
<span class="n">A</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">BF1</span><span class="o">.</span><span class="n">get_IntOp</span><span class="p">(</span><span class="n">Deriv</span><span class="o">=</span><span class="s">&#39;D0&#39;</span><span class="p">)</span>
<span class="n">Int</span> <span class="o">=</span> <span class="n">BF1</span><span class="o">.</span><span class="n">get_IntVal</span><span class="p">(</span><span class="n">Coefs</span><span class="o">=</span><span class="n">Coefs</span><span class="p">,</span> <span class="n">Deriv</span><span class="o">=</span><span class="s">&#39;D0&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">m</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">Int</span>
<span class="c"># (30,) 0</span>
</pre></div>
</div>
<p>When m==0, it means that A is a vector (Int=A*Coefs), and when m==1, it means A is matrix and the integral requires a square operation (Int=Coefs*A*Coefs).
The following integrals are implemented:</p>
<table border="1" class="docutils">
<caption>The available values of the &#8216;Deriv&#8217; keyword argument for integral computation</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0 or &#8216;D0&#8217;</td>
<td>The integrals of the B-splines themselves (0-th order derivative, integrals of higher order derivatives are all zero)</td>
</tr>
<tr class="row-odd"><td>&#8216;D0N2&#8217;, &#8216;D1N2&#8217;, &#8216;D2N2&#8217;, &#8216;D3N2&#8217;</td>
<td>The integrals of the squared norm of the 0th, 1st, 2nd and 3rd order derivatives (only 0-th order derivative implemented so far, for Deg=0,1, but not for Deg=2,3)</td>
</tr>
<tr class="row-even"><td>&#8216;D1FI&#8217;</td>
<td>The integrated Fisher Information, not implemented so far</td>
</tr>
</tbody>
</table>
<p>Finally, you can also plot a series of selected basis functions and there associated mesh elements (useful for detailed analysis and for debugging). Note tht you can also provide a &#8216;Coefs&#8217; vector if you do not wish to use the default Coefs=1. value for representation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ax</span> <span class="o">=</span> <span class="n">BF1</span><span class="o">.</span><span class="n">plot_Ind</span><span class="p">(</span><span class="n">Ind</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">Elt</span><span class="o">=</span><span class="s">&#39;LCK&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_BF1_Select.png"><img alt="Some selected basis functions and their associated mesh centers and knots" src="_images/Fig_Tutor_ToFuMesh_BF1_Select.png" style="width: 500.0px; height: 300.0px;" /></a>
<p class="caption">Some selected basis functions and their associated mesh centers and knots</p>
</div>
<p>All these functionalities are also found in the BaseFunc2D object, which additionally provides specific attributes and methods:</p>
<table border="1" class="docutils">
<caption>The attributes of a BaseFunc2D object</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>self.ID</td>
<td>The ID class of the object</td>
</tr>
<tr class="row-odd"><td>self.Mesh</td>
<td>The Mesh2D object on which the basis functions are built</td>
</tr>
<tr class="row-even"><td>self.LFunc, self.NFunc, self.Deg, self.Bound</td>
<td>The list of basis functions and the number of basis functions (self.NFunc=len(self.LFunc)), the degree of the basis functions, and the boundary condition (only 0 implemented so far, all points have 1 multiplicity)</td>
</tr>
<tr class="row-odd"><td>self.Func_Centsind, self.Func_Knotsind, self.Func_PMax</td>
<td>An array giving the correspondence index between each basis function and all its associated mesh centers (and there are methods to go the other way around), its associated mesh knots, and the position of the maximum of each basis function (either oa mesh center or a knot depending on its degree).</td>
</tr>
<tr class="row-even"><td>self.FuncInterFunc</td>
<td>An array containing indices of all neighbouring basis functions of each basis function (neighbouring in the sense that the intersection of their respective supports is non-zero)</td>
</tr>
</tbody>
</table>
<p>Due to its 2D nature, the BaseFunc2D object class is also equiped with methods to get the support (self.get_SuppRZ) and quadrature points (self.get_quadPoints) of each basis function.</p>
<p>Like the BaseFunc1D object, it provides a method for a least square fit of an input function. In the following example, the coefficients are determined using this method and then fed to various plotting methods used to visalise the function itself or some of its derivatives:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">BF2</span> <span class="o">=</span> <span class="n">TFM</span><span class="o">.</span><span class="n">BaseFunc2D</span><span class="p">(</span><span class="s">&#39;BF2&#39;</span><span class="p">,</span><span class="n">M2bis</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>                                                                                                             <span class="c"># Defining the BaseFunc2D object</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">PathFile = RP + &#39;/Inputs/AUG_Tor.txt&#39;</span>
<span class="sd">PolyRef = np.loadtxt(PathFile, dtype=&#39;float&#39;, comments=&#39;#&#39;, delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=2)</span>
<span class="sd">Tor2 = TFG.Tor(&#39;AUG&#39;,PolyRef)                                                                                                                   # Defining the Tor object for the Emiss function definition</span>
<span class="sd">def Emiss(Points):                                                                                                                              # Definition of the inpout Emiss function</span>
<span class="sd">    R  = np.sqrt(Points[0,:]**2+Points[1,:]**2)</span>
<span class="sd">    Z = Points[2,:]</span>
<span class="sd">    Val = np.exp(-(R-1.68)**2/0.20**2 - (Z-0.05)**2/0.35**2) - 0.50*np.exp(-(R-1.65)**2/0.08**2 - (Z-0.05)**2/0.15**2)</span>
<span class="sd">    ind = Tor2.isinside(np.array([R,Z]))</span>
<span class="sd">    Val[~ind] = 0.</span>
<span class="sd">    return Val</span>

<span class="sd">ax1, ax2 = BF2.plot_fit(ff=Emiss)                                                                                                               # Plotting the fitted function</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">Coefs</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="c">#BF2.get_Coefs(ff=Emiss)                                                                                                            # Extracxting the coefficients corresponding to the fitted function</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="s">f, axarr = plt.subplots(2,4, sharex=True, facecolor=&quot;w&quot; ,figsize=(20,13))</span>
<span class="s">ax = BF2.plot(ax=axarr[0,0], Coefs=Coefs,Deriv=&#39;D1&#39;, DVect=TFD.BF2_DVect_Def)                                                                   # Plotting the gradient scalar vertical vector (Z-component)</span>
<span class="s">ax.axis(&quot;equal&quot;), ax.set_title(&quot;D1-Z&quot;)</span>
<span class="s">ax = BF2.plot(ax=axarr[1,0], Coefs=Coefs,Deriv=&#39;D1&#39;, DVect=TFD.BF2_DVect_Defbis)                                                                # Plotting the gradient scalar horizontal vector (R-vector)</span>
<span class="s">ax.axis(&quot;equal&quot;), ax.set_title(&quot;D1-R&quot;)</span>
<span class="s">ax = BF2.plot(ax=axarr[0,1], Coefs=Coefs,Deriv=&#39;D1N2&#39;)                                                                                          # Plotting the squared norm of the gradient</span>
<span class="s">ax.axis(&quot;equal&quot;), ax.set_title(&quot;D1N2&quot;)</span>
<span class="s">ax = BF2.plot(ax=axarr[1,1], Coefs=Coefs,Deriv=&#39;D1FI&#39;)                                                                                          # Plotting the local fisher information</span>
<span class="s">ax.axis(&quot;equal&quot;), ax.set_title(&quot;D1FI&quot;)</span>
<span class="s">ax = BF2.plot(ax=axarr[0,2], Coefs=Coefs,Deriv=&#39;D2Lapl&#39;)                                                                                        # Plotting the laplacian</span>
<span class="s">ax.axis(&quot;equal&quot;), ax.set_title(&quot;D2Lapl&quot;)</span>
<span class="s">ax = BF2.plot(ax=axarr[1,2], Coefs=Coefs,Deriv=&#39;D2LaplN2&#39;)                                                                                      # Plotting the squared norm of the laplacian</span>
<span class="s">ax.axis(&quot;equal&quot;), ax.set_title(&quot;D2LaplN2&quot;)</span>
<span class="s">ax = BF2.plot(ax=axarr[0,3], Coefs=Coefs,Deriv=&#39;D2Gauss&#39;)                                                                                       # Plotting the Gaussian curvature of the surface</span>
<span class="s">ax.axis(&quot;equal&quot;), ax.set_title(&quot;D2Gauss&quot;)</span>
<span class="s">ax = BF2.plot(ax=axarr[1,3], Coefs=Coefs,Deriv=&#39;D2Mean&#39;)                                                                                        # Plotting the Mean curvature of the surface</span>
<span class="s">ax.axis(&quot;equal&quot;), ax.set_title(&quot;D2Mean&quot;)</span>
<span class="s">plt.show()</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_BF2.png"><img alt="Input 2D emissivity model and fitted BaseFunc2D" src="_images/Fig_Tutor_ToFuMesh_BF2.png" style="width: 500.0px; height: 300.0px;" /></a>
<p class="caption">Input 2D emissivity model and fitted BaseFunc2D</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_BF2_Deriv.png"><img alt="Series of derivatives or local quantities of interest of the fitted BaseFunc2D object" src="_images/Fig_Tutor_ToFuMesh_BF2_Deriv.png" style="width: 1200.0px; height: 800.0px;" /></a>
<p class="caption">Series of derivatives or local quantities of interest of the fitted BaseFunc2D object</p>
</div>
<p>Like for the BaseFunc1D object, and in order to facilitate detailed analysis and possibly debugging, you can also plot the key points, support and value of some selected basis functions of your choice:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ax</span> <span class="o">=</span> <span class="n">BF2</span><span class="o">.</span><span class="n">plot_Ind</span><span class="p">(</span><span class="n">Ind</span><span class="o">=</span><span class="p">[</span><span class="mi">200</span><span class="p">,</span><span class="mi">201</span><span class="p">,</span><span class="mi">202</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span><span class="mi">301</span><span class="p">,</span><span class="mi">302</span><span class="p">,</span> <span class="mi">622</span><span class="p">,</span><span class="mi">623</span><span class="p">,</span><span class="mi">624</span><span class="p">,</span><span class="mi">625</span><span class="p">,</span><span class="mi">626</span><span class="p">,</span> <span class="mi">950</span><span class="p">],</span> <span class="n">Elt</span><span class="o">=</span><span class="s">&#39;L&#39;</span><span class="p">,</span> <span class="n">EltM</span><span class="o">=</span><span class="s">&#39;M&#39;</span><span class="p">,</span> <span class="n">Coefs</span><span class="o">=</span><span class="n">Coefs</span><span class="p">)</span>                                         <span class="c"># Plotting local basis functions values and mesh</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">BF2</span><span class="o">.</span><span class="n">plot_Ind</span><span class="p">(</span><span class="n">Ind</span><span class="o">=</span><span class="p">[</span><span class="mi">200</span><span class="p">,</span><span class="mi">201</span><span class="p">,</span><span class="mi">202</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span><span class="mi">301</span><span class="p">,</span><span class="mi">302</span><span class="p">,</span> <span class="mi">622</span><span class="p">,</span><span class="mi">623</span><span class="p">,</span><span class="mi">624</span><span class="p">,</span><span class="mi">625</span><span class="p">,</span><span class="mi">626</span><span class="p">,</span> <span class="mi">950</span><span class="p">],</span> <span class="n">Elt</span><span class="o">=</span><span class="s">&#39;SP&#39;</span><span class="p">,</span> <span class="n">EltM</span><span class="o">=</span><span class="s">&#39;MCK&#39;</span><span class="p">,</span> <span class="n">Coefs</span><span class="o">=</span><span class="n">Coefs</span><span class="p">)</span>                                      <span class="c"># Plotting local basis functions support and PMax and mesh with centers and knots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_BF2_Int1.png"><img alt="Local values of the selected local basis functions, with the underlying mesh" src="_images/Fig_Tutor_ToFuMesh_BF2_Int1.png" style="width: 400.0px; height: 400.0px;" /></a>
<p class="caption">Local values of the selected local basis functions, with the underlying mesh</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Fig_Tutor_ToFuMesh_BF2_Int2.png"><img alt="Support and PMax of the selected local basis functions, with the underlying mesh and centers and knots associated to the selected local basis functions" src="_images/Fig_Tutor_ToFuMesh_BF2_Int2.png" style="width: 400.0px; height: 400.0px;" /></a>
<p class="caption">Support and PMax of the selected local basis functions, with the underlying mesh and centers and knots associated to the selected local basis functions</p>
</div>
<p>Finally, you can access values and operators of interest regarding some integrated quantities like the squared norm of the gradient, the squared laplacian (to be finished)...</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">BF2</span><span class="o">.</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Surf</span>
<span class="k">print</span> <span class="s">&quot;Int radiation : &quot;</span><span class="p">,</span> <span class="n">BF2</span><span class="o">.</span><span class="n">get_IntVal</span><span class="p">(</span><span class="n">Deriv</span><span class="o">=</span><span class="s">&#39;D0&#39;</span><span class="p">,</span> <span class="n">Coefs</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Int sq. gradient : &quot;</span><span class="p">,</span> <span class="n">BF2</span><span class="o">.</span><span class="n">get_IntVal</span><span class="p">(</span><span class="n">Deriv</span><span class="o">=</span><span class="s">&#39;D1N2&#39;</span><span class="p">,</span> <span class="n">Coefs</span><span class="o">=</span><span class="n">Coefs</span><span class="p">)</span>
<span class="c"># 1.69963173663</span>
<span class="c"># Surf :</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Vol :</span>
<span class="c"># Surf :</span>
<span class="c"># Vol :</span>
</pre></div>
</div>
<p>The following table lists the operators which are available in <strong>ToFu_Mesh</strong>, depending on the value of the kwdarg &#8216;Deriv&#8217;:</p>
<table border="1" class="docutils">
<caption>The available values of the &#8216;Deriv&#8217; keyword argument for integral computation</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0 or &#8216;D0&#8217;</td>
<td>The integrals of the B-splines themselves (integrals of higher order derivatives are all zero)</td>
</tr>
<tr class="row-odd"><td>&#8216;D0N2&#8217;, &#8216;D1N2&#8217;, &#8216;D2N2&#8217;, &#8216;D3N2&#8217;</td>
<td>The integrals of the squared norm of the 0th, 1st, 2nd and 3rd order derivatives (only 0-th order derivative implemented so far, for Deg=0,1, but not for Deg=2,3)</td>
</tr>
<tr class="row-even"><td>&#8216;D1FI&#8217;</td>
<td>The integrated Fisher Information, not implemented so far</td>
</tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><strong>ToFu_Mesh</strong></a><ul>
<li><a class="reference internal" href="#getting-started-with-tofu-mesh">Getting started with ToFu_Mesh</a></li>
<li><a class="reference internal" href="#the-mesh1d-mesh2d-and-mesh3d-object-classes">The Mesh1D, Mesh2D and Mesh3D object classes</a></li>
<li><a class="reference internal" href="#the-basefunc1d-basefunc2d-and-basefunc3d-object-classes">The BaseFunc1D, BaseFunc2D and BaseFunc3D object classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="ToFu_Geom.html"
                        title="previous chapter"><strong>ToFu_Geom</strong></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ToFu_MatComp.html"
                        title="next chapter"><strong>ToFu_MatComp</strong></a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/ToFu_Mesh.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ToFu_MatComp.html" title="ToFu_MatComp"
             >next</a> |</li>
        <li class="right" >
          <a href="ToFu_Geom.html" title="ToFu_Geom"
             >previous</a> |</li>
        <li><a href="index.html">ToFu alpha documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, D. Vezinet, A. Ratnani.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>