% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{ToFu Documentation}
\date{October 09, 2014}
\release{alpha}
\author{D. Vezinet, A. Ratnani}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Overview}
\label{overview:overview}\label{overview::doc}\label{overview:welcome-to-tofu-s-documentation}\label{overview:id1}
(This project is not finalised yet, work in progress...)

\textbf{ToFu}, which stands for ``TOmography for FUsion'' is a python package (with parts in C/C++) providing all necessary tools for tomography diagnostics for the Fusion community, it is particularly relevant for X-ray and bolometer diagnostics on Tokamaks. On of the objectoves is to provide a common tool for tomographic inversions, with both accurate methods and enough flexibility to be easily adapted to any Tokamak and to the specific requirements of each user. The main language (Python) has been chosen for its open-source philosophy, for its object-oriented capacities, and for the good performance / flexibility ratio that it offers. The architecture of the \textbf{ToFu} package is intended to be modular to allow again for maximum flexibility and to facilitate customisation and evolutivity from the users.
\begin{description}
\item[{\textbf{ToFu}: provides in particular, but not only, the main following functionnalities :}] \leavevmode\begin{itemize}
\item {} 
Using the 3D geometry of the diagnostic (positions of detectors and apertures are provided as inputs) to compute quantities of interest (e.g.: the optimal line of sight, the exact etendue..). This is done by the module ToFu\_Geom.

\item {} 
Building of a variable grid size mesh for spatial discretisation of the solution (i.e. emissivity field) on which B-splines of any degree can be added to serve as Local Basis Functions. This is done by the module ToFu\_Mesh.

\item {} 
Computing of the geometry matrix associated to a set of detectors and a set of basis functions, both with a full 3D approach or with a Line Of Sight (LOS) approximation. This is done by the module ToFu\_MatComp, which uses both ToFu\_Geom and ToFu\_Mesh.

\item {} 
Computing tomographic inversions based on the constructed geometry matrix and Phillips-Tikhonov inversion with a choice of objective functionals (among which first order and second order derivatives or Fisher information, and more to come). This is done by the module ToFu\_Inv, which uses the matrix computed by ToFu\_MatComp.

\item {} 
Visualizing, exploring and interpreting the resulting inversions using a built-in Graphic User Interface.

\end{itemize}

\item[{The joint use of a full 3D approach and of regular basis functions (B-splines) allows for advanced functionalities and flexibility, like in particular :}] \leavevmode\begin{itemize}
\item {} 
Accurate computation of etendue and geometry matrix.

\item {} 
Exact differential operators (provided sufficient degree of the basis function) instead of discretised operators (this feature and the previous one aim at improving the accuracy of tomographic inversions).

\item {} 
Accurate description of toroidal-viewing detectors with potentially large viewing cones and for which the LOS approximation cannot be used.

\item {} 
Making possible 3D inversions (provided the geometrical coverage of the plasma volume is sufficient, for example thanks to toroidal-viewing detectors).

\item {} 
Enabling proper taking into acccount of anisotropic radiation (for example due to fast electrons due to disruptions).

\end{itemize}

\item[{The \textbf{ToFu} package has built-in mesh and B-spline definitions, however, if used alone, it can only create and handle rectangular mesh (with variable grid size though). In order to allow for more optimised mesh and basis functions, the \textbf{ToFu} package is fully compatible with \textbf{Pigasus} (and \textbf{CAID}), which is a another Python package (with a Fortran core), which uses cutting-edge technologies from Computer-Assisted Design (CAD) to create optimised mesh (using Non-Unifrom}] \leavevmode
Rational B-Splines, or NURBS, curves) on which it can also add several different types of regular basis functions. It is a next-gen solution for optimisation of plasma-physics simulation codes. Hence, the final idea is that the same mesh and tools can be used for running CPU-expensive plasma physics simulations and, from their output, to compute the associated simulated measurements on any radiation diagnostics. This synthetic diagnostic approach is aimed at facilitating direct
comparisons between simulations and experimental measurements and at providing the community with flexible and cross-compatible tools to fit their needs. Plasma physics codes that are planning on using \textbf{Pigasus} in a near future include in particuler \textbf{JOREK} (in its \textbf{Django} version) and \textbf{GISELA} (in its next version). More information about \textbf{Pigasus} (lien), \textbf{JOREK} (lien) and \textbf{GISELA} can be found on their respective pages.

\end{description}

In order to avoid too much dependency issues, the \textbf{ToFu} package resorts to widely used Python libraries like scipy, numpy and matplotlib. Whenever it was possible, the idea was either to use a very common and accessible library or to have built-in methods doing the job. It can be run as a stand-alone on an offline computer (i.e.: on a laptop while travelling), in an online mode (using a central database on the internet) and with or without \textbf{Pigasus} (keeping in mind that only rectangular mesh can be created without it).

For faster computation, some modules and/or methods are coded with Cython or Boost.Pyton. It is also intended to be MPI and OpenMP parallelized.

The general architecture is briefly represented in figure ??.

This general overview shows all the \textbf{ToFu} modules and their main functionnalities and dependancies. Particularly important are the ``preparatory modules'' \textbf{ToFu\_Geom}, \textbf{ToFu\_Mesh} and \textbf{ToFu\_MatComp} wich provide all necessary tools to pre-calculate the geometry matrix which is a key feature of the two main uses of \textbf{ToFu}. On way to use \textbf{ToFu} is as a synthetic diagnostic since from a simulated emissivity field it can compute the corresponding synthetic measurements for comparison with experimental measurements, which is illustrated in figure ??. Another to use \textbf{ToFu} is to go the other way around : use the experimental measurements to compute a reconstructed experimental emissivity field via a tomographic inversion, for comparisopn with a simulated emissivity field or simply for getting an idea of what the emissivity field looks like, which is illustrated in figure ??.

The following will go into further details regarding each module.

ToDo list :
* Rest of documentation, with relevant references (like :cite:Ingesson08FST) and figures
* Tutorial
* ToFu\_Inv
* GUI (one for each module)
* Accelerate existing modules with Cython, Boost.Python + Parallelization
* Use it to do some physics at last !!!


\chapter{ToFu\_Geom}
\label{ToFu_Geom:overview}\label{ToFu_Geom:tofu-geom}\label{ToFu_Geom::doc}
(This project is not finalised yet, work in progress...)

\textbf{ToFu\_Geom}, is the first ToFu-specific module, it is dedicated to handling the 3D geometry of the diagnostic of interest. It defines 6 objects classes and many functions used as objects methods. It resorts to a module called \textbf{General\_Geom}, which is not ToFu-specific (i.e.: it mostly conatins functions and has no reference to ToFu objects), which should be entirely re-written using Cython for faster computation. As all the other ToFu-specific modules, \textbf{ToFu\_Geom} not only defines computing methods but also a variety of plotting methods that can be used to visualise various aspects and characteristics of the diagnostics as well as for debugging.
This section will first give a general presentation of the \textbf{ToFu\_Geom} module and will then give a tutorial for building your own diagnostic.

\textbf{ToFu} is designed for handling passive radiation detectors (e.g.: bolometer foils, semi-conductor diodes or gas detectors), which can be placed behind an arbitrary number of collimating apertures of any shape and orientation. This goes also for the detector, represented by its active surface (the only constraint for apertures and detectors - in the current version - is that each must be represented by a planar polygon, but they do not have to be co-planar). Each detector is thus associated to a list of apertures through which it ``sees'' a certain volume. The volume of interest is limited, in the case of a Tokamak, to a chamber (i.e.: the vacuum vessel) represented in \textbf{ToFu} by a toroid, itself defined by a reference 2D polygon (usually the best possible representation of the inner walls of the Tokamak) which is then expanded toroidally. The volume ``seen'' by each detector is then the fraction of the toroid that it can ``see'' directly through its various apertures. On most fusion devices, such passive radiation detectors are located in a poloidal cross-section and arranged so that their cone of vision is very thin, such that it can be represented by a simple line (called a Line Of Sigh, or LOS) and an etendue. \textbf{ToFu\_Geom} allows for a full 3D description of the whole system, and also for an accurate computation of the geometrically optimal LOS and its associated etendue value. Hence, it is possible to do everything with the two approaches (full 3D or LOS) and quatify the error due to the LOS approximation, if any.

This short introduction gives the key points addressed by \textbf{ToFu\_Geom}, which can be summarized by listing the 7 object classes and their meaning :


\begin{threeparttable}
\capstart\caption{The object classes in ToFu\_Geom}

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{
Name
} & \textbf{
Description
} & \textbf{
Inputs needed
}\\\hline

ID
 & 
An identity object that is used by all \textbf{ToFu} objects to store specific identity information (name, file name if the object is to be saved, names of other objects necessary for the object creation, date of creation, signal name, signal group, version...)
 & 
By default only a name (a character string) is necessary, A default file name is constructed (including the object class and date of creation), but every attribute can be modified and extra attribute can be added to suit the specific need of the the data acquisition system of each fusion experiment or the naming conventions of each laboratory.
\\\hline

Tor
 & 
The limits of the toroidal chamber
 & 
A 2D polygon in (R,Z) coordinates
\\\hline

LOS
 & 
A LOS, can be defined by the user for tests, but usually defined by the Detect object as an output
 & 
A Tor object, a starting point and a unitary vector indicating the direction of observation (the end point is computed), both in 3D (X,Y,Z) coordinates
\\\hline

GLOS
 & 
A group of LOS objects, with a name (useful for defining cameras which are sets of detectors with a common aperture and a commom name)
 & 
A list of LOS objects
\\\hline

Aperture
 & 
An aperture, represented by a planar polygon
 & 
A Tor object and a planar polygon in 3D (X,Y,Z) coordinates
\\\hline

Detect
 & 
A detector, represented by its planar active surface, computed a geometrically optimal LOS as an output
 & 
A Tor object, a planar polygon in 3D (X,Y,Z) coordinates, and a list of Aperture objects
\\\hline

GDetect
 & 
A group of Detect objects, useful for defining cameras
 & 
A list of Detect objects
\\\hline
\end{tabulary}

\end{threeparttable}


The following will give a more detailed description of each object and its attributes and methods through a tutorial at the end of which you should be able to create your own diagnostics and access its main geometrical characteristics (the will be computed automatically).


\chapter{Getting started with \textbf{ToFu\_Geom}}
\label{ToFu_Geom:getting-started-with-tofu-geom}
Once you have downloaded the whole \textbf{ToFu} package (and made sur you also have scipy, numpy and matplotlib, as well as a free polygon-handling library called Polygon which can be downloaded at ), just start a python interpreter and import \textbf{ToFu\_Geom} (we will always import \textbf{ToFu} modules `as' a short name to keep track of the functionalities of each module). To handle the local path of your computer, we will also import the small module called \textbf{ToFu\_PathFile}, and \textbf{matplotlib} and \textbf{numpy} will also be useful:


\chapter{The Tor object class}
\label{ToFu_Geom:the-tor-object-class}
To define the volume of the vacuum chamber, you need to know the (R,Z) coordinates of its reference polygon (in a poloidal cross-section). You should provide it as a (2,N) numpy array where N is the number of points defining the polygon. To give the Tor object its own identity you should at least choose a name (i.e.: a character string). For more elaborate identification, you can define an ID object and give as an input instead of a simple name. You can also provide the position of a ``center'' of the poloidal cross-section (in 2D (R,Z) coordinates as a (2,1) numpy array) that will be used to compute the coordinates in transformation space any LOS using this Tor object (and the sinogram of any scalar emissivity field using this Tor object). If not provided, the center of mass of the reference polygon is used as a default ``center''.

In the following, we will use the geometry of ASDEX Upgrade as a example.
We first have to give a reference polygon (`PolyRef' below) as a (2,N) numpy array in (R,Z) coordinates.

Alternatively, you can store PolyRef in a file and save this file locally, or use one of the default tokamak geometry stored on the \textbf{ToFu} database where Tor input polygons are stored in 2 lines .txt files (space-separated values of the R coordinates on the first line, and corresponding Z coordinates on the second line). Here, we use the default ASDEX Upgrade reference polygon stored in AUG\_Tor.txt.

We now have created two Tor objects, and \textbf{ToFu\_Geom} has computed a series of geometrical characteristics that will be useful later (or that simply provide general information).
In particular, we have access to the following attributes :


\begin{threeparttable}
\capstart\caption{The attributes of a Tor object}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
Attribute
} & \textbf{
Description
}\\\hline

self.Poly
 & 
The reference polygon used to create the Tor object, as a (2,N) numpy array, where N is the number of points (the last one being identical to the first one)
\\\hline

self.ID
 & 
The ID class of the Tor object
\\\hline

self.BaryP
 & 
The barycenter of self.Poly
\\\hline

self.Surf
 & 
The surface of self.Poly
\\\hline

self.BaryS
 & 
The center of mass of self.Poly
\\\hline

self.Vect
 & 
The 2D vectors representing the edges of self.Poly as a (2,N) numpy array
\\\hline

self.Vin
 & 
The normalised 2D vectors oriented towards the inside of self.Poly for each edge
\\\hline

self.PRMin, self.PRMax
 & 
The points of self.Poly with the maximum (resp. minimum) R coordinate, as a (2,1) numpy array (one for PRMin, one for PRMax)
\\\hline

self.PZMin, self.PZMax
 & 
The points of self.Poly with the maximum (resp. minimum) Z coordinate, as a (2,1) numpy array (one for ZPMin, one for PZMax)
\\\hline

self.ImpRZ
 & 
The (R,Z) coordinates of the point used for computing the impact factor (i.e. the coordinates in projection space(lien)) of the LOS objects using this Tor and of the enveloppe of this Tor (default is self.BaryS)
\\\hline

self.Imp\_EnvTheta
 & 
The discretized values used for computing the enveloppe of Tor in projection space (where theta is in {[}0,pi{]}, (lien))
\\\hline

self.Imp\_EnvMinMax
 & 
The enveloppe of Tor in projection space (lien) (i.e.: the - algebraic - minimum and maximum impact factor of the reference polygon for each value of self.Imp\_EnvTheta)
\\\hline
\end{tabulary}

\end{threeparttable}


In addition to these attributes, the Tor object has a number of built-in methods that can be used to visualise its characteristics. As in the whole \textbf{ToFu} package, the object methods used for plotting always begin with ``{\color{red}\bfseries{}self.plot\_}...'', where the name of the method after ``{\color{red}\bfseries{}plot\_}...'' is relatively explicit. All the plotting methods are based on matplotlib, and in order to allow for flexibility and customization, you can either pass as input an already existing matplotlib axes on which to plot, or use a predefined default axes (simply by not specifying any axes). Similarly, extensive use of keyword argumants with default values is made, thus all plotting options are customizable since you can pass a dictionnary for element to be plotted (see the detailed documentation of each method to know which kwarg to use for which element).

As an example, you can plot the reference polygon of ASDEX Upgrade in both a poloidal and a toroidal projection, using the default axes (defined in \textbf{ToFu\_Geom}) :

We can then re-use the axes of the poloidal projection to plot the vectors defining the edges and the inner side of the reference polygon:

(for some mysterious reason it is not working on my Linux station, but it does work on my macbook, as it should)

We can also plot a 3D representation of the reference polygon, and specify that we only want to plot a fraction of it, between pi/4 and 7pi/4:

We can also visualise the enveloppe of ASDEX Upgrade in the projection space (lien), in 2D or 3D, with a color of our choosing :

Feel free to explore the various keyword arguments of each method.
This Tor object can then be used as a limit to the volume that can be detected by each LOS or Detect object.


\chapter{The LOS object class}
\label{ToFu_Geom:the-los-object-class}
Since most tomography users in the fusion community are familiar with the LOS approximation (which gives satisfactory results in most usual situations), we choose to provide in \textbf{ToFu} the two extremes of the spectrum : a pure LOS approximation, and a full 3D approach. Any attempt to compute the geometry matrix with an ``advanced'' or ``improved'' LOS approximation (i.e.: taking into account finite beam width, using anti-aliasing techniques with pixels...) can be considered to fall somewhere between these two extremes, and since every user has his own recipes, we do not provide any except the two extreme approaches. Obviously, all users can download \textbf{ToFu} and add there own recipe in their local version (this should be done in the \textbf{ToFu\_MatComp} module). Hence, a pure LOS object exists in \textbf{ToFu}, and can be defined with minimum knowledge of the diagnostics : only a point (D) and a unitary vector (u) are necessary for each LOS. The unitary vector shall be pointing towards the direction of observation (i.e.: towards the interior of the vacuum chamber).
nce a LOS id defined, \textbf{ToFu} automatically computes a series of points of interest. Indeed, if a Tor object is provided to the LOS object, we can determine the first point of entry into the Tor volume (PIn), and the point were the LOS gets out of it (POut). We can also determine the point on the LOS with minimum R-coordinate (PRMin, which is usually PIn or POut except when the LOS has a strong toroidal inclination, in which case PRMin is somewhere in the middle of the LOS). If the LOS object has a RZImp (by default the RZImp of the associated Tor object), then the impact parameter of the LOS with respect to this RZImp can be computed (has well as its two associated angles), and the LOS can be represented in projection space.

Hence, a LOS object has the following attributes :


\begin{threeparttable}
\capstart\caption{The attributes of a Tor object}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
Attribute
} & \textbf{
Description
}\\\hline

self.Poly
 & 
The reference polygon used to create the Tor object, as a (2,N) numpy array, where N is the number of points (the last one being identical to the first one)
\\\hline

self.ID
 & 
The ID class of the Tor object
\\\hline

self.D
 & 
The starting point of the LOS (usually the center of mass of the associated detector or the center of mass of the collimating slit for fan-like cameras)
\\\hline

self.u
 & 
The unitary direction vector (oriented towards the interior of the associated Tor)
\\\hline

self.Tor
 & 
The associated Tor object
\\\hline

self.
 & 
The 2D vectors representing the edges of self.Poly as a (2,N) numpy array
\\\hline

self.Vin
 & 
The normalised 2D vectors oriented towards the inside of self.Poly for each edge
\\\hline

self.PRMin, self.PRMax
 & 
The points of self.Poly with the maximum (resp. minimum) R coordinate, as a (2,1) numpy array (one for PRMin, one for PRMax)
\\\hline

self.PZMin, self.PZMax
 & 
The points of self.Poly with the maximum (resp. minimum) Z coordinate, as a (2,1) numpy array (one for ZPMin, one for PZMax)
\\\hline

self.ImpRZ
 & 
The (R,Z) coordinates of the point used for computing the impact factor (i.e. the coordinates in projection space(lien)) of the LOS objects using this Tor and of the enveloppe of this Tor (default is self.BaryS)
\\\hline

self.Imp\_EnvTheta
 & 
The discretized values used for computing the enveloppe of Tor in projection space (where theta is in {[}0,pi{]}, (lien))
\\\hline

self.Imp\_EnvMinMax
 & 
The enveloppe of Tor in projection space (lien) (i.e.: the - algebraic - minimum and maximum impact factor of the reference polygon for each value of self.Imp\_EnvTheta)
\\\hline
\end{tabulary}

\end{threeparttable}

\begin{gather}
\begin{split}\nabla^2 u = \sin(x)\end{split}\notag
\end{gather}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
